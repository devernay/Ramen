<!--
    Copyright 2005-2008 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <TITLE>Adobe Software Technology Lab: string.hpp Source File</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="stlab.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
</head>
<body>
<div id='content'>
<table><tr>
<td colspan='5'>
    <div id='opensource_banner'>
    <table style='width: 100%; padding: 5px;'><tr>
    <td align='left'>
        <a href='index.html' style='border: none'><img src='stlab2007.jpg' alt="stlab.adobe.com"/></a>
    </td>
    <td align='right'>
        <a href='http://www.adobe.com' style='border: none'><img src='adobe_hlogo.gif' alt="Adobe Systems Incorporated"/></a>
    </td>
    </tr></table>
    </div>
</td></tr><tr>
<td valign="top">
    <div id='navtable' height='100%'>
    <div style='margin: 5px'>
        <h4>Documentation</h4>

        <a href="group__asl__overview.html">Overview</a><br/>
        <a href="asl_readme.html">Building ASL</a><br/>
        <a href="asl_toc.html">Documentation</a><br/>
        <a href="http://stlab.adobe.com/wiki/index.php/Supplementary_ASL_Documentation">Library Wiki Docs</a><br/>
        <a href="asl_indices.html">Indices</a><br/>
        <a href="http://stlab.adobe.com/perforce/">Browse Perforce</a><br/>

        <h4>More Info</h4>

        <a href="asl_release_notes.html">Release Notes</a><br/>
        <a href="http://stlab.adobe.com/wiki/">Wiki</a><br/>
        <a href="asl_search.html">Site Search</a><br/>
        <a href="licenses.html">License</a><br/>
        <a href="success_stories.html">Success Stories</a><br/>
        <a href="asl_contributors.html">Contributors</a><br/>

        <h4>Media</h4>

        <a href="http://sourceforge.net/project/showfiles.php?group_id=132417&amp;package_id=145420">Download</a><br/>
        <a href="asl_download_perforce.html">Perforce Depots</a><br/>

        <h4>Support</h4>

        <a href="http://sourceforge.net/projects/adobe-source/">ASL SourceForge Home</a><br/>
        <a href="http://sourceforge.net/mail/?group_id=132417">Mailing Lists</a><br/>
        <a href="http://sourceforge.net/forum/?group_id=132417">Discussion Forums</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724218&amp;group_id=132417&amp;func=browse">Report Bugs</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724221&amp;group_id=132417&amp;func=browse">Suggest Features</a><br/>
        <a href="asl_contributing.html">Contribute to ASL</a><br/>

        <h4>RSS</h4>

        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417">Short-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1">Full-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projfiles.php?group_id=132417">File releases</a><br/>

        <h4>Other Adobe Projects</h4>

        <a href="adobe_apollo.html">Adobe Air</a><br/>
        <a href="http://stlab.adobe.com/gil/">Adobe GIL</a><br/>
        <a href="http://stlab.adobe.com/performance/">C++ Benchmarks</a><br/>
        <a href="http://labs.adobe.com">Adobe Labs</a><br/>
        <a href="http://stlab.adobe.com/amg/">Adobe Media Gallery</a><br/>
        <a href="http://www.adobe.com/products/xmp/">Adobe XMP</a><br/>
        <a href="http://www.mozilla.org/projects/tamarin">Tamarin project<br/>(Mozilla Foundation)</a><br/>

        <h4>Other Resources</h4>

        <a href="http://boost.org">Boost</a><br/>
        <a href="http://www.riaforge.com/">RIAForge</a><br/>
        <a href="http://www.sgi.com/tech/stl">SGI STL</a><br/>
    </div>
    </div>
</td>
<td id='maintable' width="100%" valign="top">

<!-- End Header -->
<!-- Generated by Doxygen 1.5.9 -->
<h1>string.hpp</h1><a href="string_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">    Copyright 2005-2007 Adobe Systems Incorporated</span>
<a name="l00003"></a>00003 <span class="comment">    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt</span>
<a name="l00004"></a>00004 <span class="comment">    or a copy at http://stlab.adobe.com/licenses.html)</span>
<a name="l00005"></a>00005 <span class="comment">*/</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="comment">/*************************************************************************************************/</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="preprocessor">#ifndef ADOBE_STRING_HPP</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span><span class="preprocessor">#define ADOBE_STRING_HPP</span>
<a name="l00011"></a>00011 <span class="preprocessor"></span>
<a name="l00012"></a>00012 <span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">adobe/config.hpp</a>&gt;</span>
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;cstring&gt;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;functional&gt;</span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;iterator&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="preprocessor">#if defined(ADOBE_STD_SERIALIZATION)</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="preprocessor">#include &lt;iosfwd&gt;</span>
<a name="l00021"></a>00021 <span class="preprocessor">#endif</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;boost/cstdint.hpp&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;boost/operators.hpp&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;boost/static_assert.hpp&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;boost/utility.hpp&gt;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;<a class="code" href="cstring_8hpp.html">adobe/cstring.hpp</a>&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;<a class="code" href="string__fwd_8hpp.html">adobe/string_fwd.hpp</a>&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;<a class="code" href="typeinfo_8hpp.html">adobe/typeinfo.hpp</a>&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;<a class="code" href="vector_8hpp.html">adobe/vector.hpp</a>&gt;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="comment">/*************************************************************************************************/</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="keyword">namespace </span>std {
<a name="l00036"></a>00036 
<a name="l00037"></a>00037 <span class="comment">/*************************************************************************************************/</span>
<a name="l00038"></a>00038 
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharT, <span class="keyword">class</span> Traits, <span class="keyword">class</span> Allocator&gt;
<a name="l00048"></a>00048 <span class="keyword">typename</span> std::basic_string&lt;CharT, Traits, Allocator&gt;&amp;
<a name="l00049"></a><a class="code" href="group__string__algorithm.html#g16ec90d0a1670c0c255913f8381b66a6">00049</a>         operator &lt;&lt; (   std::basic_string&lt;CharT, Traits, Allocator&gt;&amp; out,
<a name="l00050"></a>00050                         <span class="keyword">const</span> std::basic_string&lt;CharT, Traits, Allocator&gt;&amp; in)
<a name="l00051"></a>00051 {
<a name="l00052"></a>00052     <span class="keyword">typename</span> std::basic_string&lt;CharT, Traits, Allocator&gt;::size_type required(in.size() + out.size());
<a name="l00053"></a>00053 
<a name="l00054"></a>00054     <span class="keywordflow">if</span> (required &gt; out.capacity()) out.reserve((<a class="code" href="group__minmax.html#gcff8a888cec2453fb4f654a2f7a37eb2" title="minmax implementation">std::max</a>)(out.capacity() * 2, required));
<a name="l00055"></a>00055 
<a name="l00056"></a>00056     out += in;
<a name="l00057"></a>00057     <span class="keywordflow">return</span> out;
<a name="l00058"></a>00058 }
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="comment">/*************************************************************************************************/</span>
<a name="l00061"></a>00061 
<a name="l00063"></a>00063 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> CharT, <span class="keyword">class</span> Traits, <span class="keyword">class</span> Allocator&gt;
<a name="l00064"></a>00064 <span class="keyword">typename</span> std::basic_string&lt;CharT, Traits, Allocator&gt;&amp; 
<a name="l00065"></a><a class="code" href="group__string__algorithm.html#g2ebcbad214c96ce9313d51e00872e7e2">00065</a>         operator &lt;&lt; (std::basic_string&lt;CharT, Traits, Allocator&gt;&amp; out_str, <span class="keyword">const</span> CharT* in_str)
<a name="l00066"></a>00066 {
<a name="l00067"></a>00067     <span class="keyword">typename</span> std::basic_string&lt;CharT, Traits, Allocator&gt;::size_type required(std::strlen(in_str) + out_str.size());
<a name="l00068"></a>00068 
<a name="l00069"></a>00069     <span class="keywordflow">if</span> (required &gt; out_str.capacity()) out_str.reserve((<a class="code" href="group__minmax.html#gcff8a888cec2453fb4f654a2f7a37eb2" title="minmax implementation">std::max</a>)(out_str.capacity() * 2, required));
<a name="l00070"></a>00070 
<a name="l00071"></a>00071     out_str += in_str;
<a name="l00072"></a>00072     <span class="keywordflow">return</span> out_str;
<a name="l00073"></a>00073 }
<a name="l00074"></a>00074 
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="comment">/*************************************************************************************************/</span>
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 } <span class="comment">// namespace std</span>
<a name="l00080"></a>00080 
<a name="l00081"></a>00081 <span class="comment">/*************************************************************************************************/</span>
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 <span class="keyword">namespace </span>adobe {
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 <span class="comment">/*************************************************************************************************/</span>
<a name="l00086"></a>00086 
<a name="l00125"></a><a class="code" href="group__string__algorithm.html#g4aea326f008c0666eb0fcc2fa39cd7f4">00125</a> <span class="keyword">inline</span> std::string <a class="code" href="group__string__algorithm.html#g4aea326f008c0666eb0fcc2fa39cd7f4">make_string</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* a, <span class="keyword">const</span> <span class="keywordtype">char</span> * b)
<a name="l00126"></a>00126 {
<a name="l00127"></a>00127     std::string result;
<a name="l00128"></a>00128     result.reserve(std::strlen(a) + std::strlen(b));
<a name="l00129"></a>00129     result += a;
<a name="l00130"></a>00130     result += b;
<a name="l00131"></a>00131     <span class="keywordflow">return</span> result;
<a name="l00132"></a>00132 }
<a name="l00133"></a>00133 
<a name="l00134"></a>00134 <span class="comment">/*************************************************************************************************/</span>
<a name="l00135"></a>00135 
<a name="l00136"></a><a class="code" href="group__string__algorithm.html#gc57b5a1e10d9e211bb8194f67112937f">00136</a> <span class="keyword">inline</span> std::string <a class="code" href="group__string__algorithm.html#g4aea326f008c0666eb0fcc2fa39cd7f4">make_string</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* a, <span class="keyword">const</span> <span class="keywordtype">char</span> * b, <span class="keyword">const</span> <span class="keywordtype">char</span>* c)
<a name="l00137"></a>00137 {
<a name="l00138"></a>00138     std::string result;
<a name="l00139"></a>00139     result.reserve(std::strlen(a) + std::strlen(b) + std::strlen(b));
<a name="l00140"></a>00140     result += a;
<a name="l00141"></a>00141     result += b;
<a name="l00142"></a>00142     result += c;
<a name="l00143"></a>00143     <span class="keywordflow">return</span> result;
<a name="l00144"></a>00144 }
<a name="l00145"></a>00145 
<a name="l00147"></a>00147 
<a name="l00148"></a>00148 <span class="comment">/*************************************************************************************************/</span>
<a name="l00149"></a>00149 
<a name="l00151"></a><a class="code" href="structadobe_1_1str__less__t.html">00151</a> <span class="keyword">struct </span><a class="code" href="structadobe_1_1str__less__t.html">str_less_t</a> : std::binary_function&lt;const char*, const char*, bool&gt;
<a name="l00152"></a>00152 {
<a name="l00153"></a><a class="code" href="structadobe_1_1str__less__t.html#18a43838ae667965d0a7cafc4f0378f7">00153</a>     <span class="keywordtype">bool</span> <a class="code" href="structadobe_1_1str__less__t.html#18a43838ae667965d0a7cafc4f0378f7">operator()</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* x, <span class="keyword">const</span> <span class="keywordtype">char</span>* y)<span class="keyword"> const</span>
<a name="l00154"></a>00154 <span class="keyword">    </span>{ <span class="keywordflow">return</span> <a class="code" href="namespaceadobe.html#699f2e83fe61caa37bbd0b06ad762eee">adobe::strcmp</a>(x, y) &lt; 0; }
<a name="l00155"></a>00155 };
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 <span class="comment">/*************************************************************************************************/</span>
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 } <span class="comment">// namespace adobe</span>
<a name="l00162"></a>00162 
<a name="l00163"></a>00163 <span class="comment">/*************************************************************************************************/</span>
<a name="l00164"></a>00164 
<a name="l00165"></a>00165 <span class="keyword">namespace </span>adobe {
<a name="l00166"></a>00166 <span class="keyword">namespace </span>version_1 {
<a name="l00167"></a>00167 
<a name="l00172"></a>00172 <span class="comment">/*************************************************************************************************/</span>
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 <span class="comment">// Move this to some appropriate file.</span>
<a name="l00176"></a>00176 <span class="comment"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived&gt;
<a name="l00177"></a><a class="code" href="classadobe_1_1version__1_1_1empty__base__t.html">00177</a> <span class="keyword">class </span><a class="code" href="classadobe_1_1version__1_1_1empty__base__t.html">empty_base_t</a> { }; <span class="comment">// Empty base to reduce size of adobe::string</span>
<a name="l00178"></a>00178     
<a name="l00179"></a>00179 <span class="comment">/*************************************************************************************************/</span>
<a name="l00180"></a>00180 
<a name="l00192"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html">00192</a> <span class="keyword">class </span><a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a> : boost::<a class="code" href="classboost_1_1totally__ordered.html">totally_ordered</a>&lt;string_t, string_t, empty_base_t&lt;string_t&gt; &gt;
<a name="l00193"></a>00193 {
<a name="l00194"></a>00194  <span class="keyword">public</span>:
<a name="l00195"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#cd77781b83256555c54fe8b83be4d624">00195</a>     <span class="keyword">typedef</span> <span class="keywordtype">char</span>                               <a class="code" href="classadobe_1_1version__1_1_1string__t.html#cd77781b83256555c54fe8b83be4d624">value_type</a>;
<a name="l00196"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#fa54b351401513c3633b87554bb7bc58">00196</a>     <span class="keyword">typedef</span> <span class="keywordtype">char</span>*                              <a class="code" href="classadobe_1_1version__1_1_1string__t.html#fa54b351401513c3633b87554bb7bc58">pointer</a>;
<a name="l00197"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#e1a2d226f681cdbbc6762fc2fef1b0e1">00197</a>     <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keywordtype">char</span>*                        <a class="code" href="classadobe_1_1version__1_1_1string__t.html#e1a2d226f681cdbbc6762fc2fef1b0e1">const_pointer</a>;
<a name="l00198"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#214162ba1a25a237fbda0ed12656b0fa">00198</a>     <span class="keyword">typedef</span> <span class="keywordtype">char</span>&amp;                              <a class="code" href="classadobe_1_1version__1_1_1string__t.html#214162ba1a25a237fbda0ed12656b0fa">reference</a>;
<a name="l00199"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#a7c6795e897d0578f7de6188861de388">00199</a>     <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keywordtype">char</span>&amp;                        <a class="code" href="classadobe_1_1version__1_1_1string__t.html#a7c6795e897d0578f7de6188861de388">const_reference</a>;
<a name="l00200"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#89a6dcafb6130e3e1bcd6d1285e0dd6f">00200</a>     <span class="keyword">typedef</span> std::size_t                        <a class="code" href="classadobe_1_1version__1_1_1string__t.html#89a6dcafb6130e3e1bcd6d1285e0dd6f">size_type</a>;
<a name="l00201"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#d319fc54a93a2c7058c70e40428ed2e2">00201</a>     <span class="keyword">typedef</span> std::ptrdiff_t                     <a class="code" href="classadobe_1_1version__1_1_1string__t.html#d319fc54a93a2c7058c70e40428ed2e2">difference_type</a>;
<a name="l00202"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#be2f3cfcfe6364b83e18496de7704ba8">00202</a>     <span class="keyword">typedef</span> <span class="keywordtype">char</span>*                              <a class="code" href="classadobe_1_1version__1_1_1string__t.html#be2f3cfcfe6364b83e18496de7704ba8">iterator</a>;
<a name="l00203"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#2f549573af49b9454e36b0e93951420c">00203</a>     <span class="keyword">typedef</span> <span class="keyword">const</span> <span class="keywordtype">char</span>*                        <a class="code" href="classadobe_1_1version__1_1_1string__t.html#2f549573af49b9454e36b0e93951420c">const_iterator</a>;
<a name="l00204"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#715e13fcafbd44d471cce6fdefbb2768">00204</a>     <span class="keyword">typedef</span> std::reverse_iterator&lt;char*&gt;       <a class="code" href="classadobe_1_1version__1_1_1string__t.html#715e13fcafbd44d471cce6fdefbb2768">reverse_iterator</a>;
<a name="l00205"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#a0640bcf574ee3fba75ee3949b843514">00205</a>     <span class="keyword">typedef</span> std::reverse_iterator&lt;const char*&gt; <a class="code" href="classadobe_1_1version__1_1_1string__t.html#a0640bcf574ee3fba75ee3949b843514">const_reverse_iterator</a>;
<a name="l00206"></a>00206 
<a name="l00207"></a>00207  <span class="keyword">private</span>:
<a name="l00208"></a>00208     <span class="keyword">typedef</span> <a class="code" href="classadobe_1_1version__1_1_1vector.html">vector&lt;value_type&gt;</a>                 <a class="code" href="classadobe_1_1version__1_1_1vector.html">storage_type</a>;
<a name="l00209"></a>00209     
<a name="l00210"></a>00210     <a class="code" href="classadobe_1_1version__1_1_1vector.html">storage_type</a> storage_m;
<a name="l00211"></a>00211 
<a name="l00212"></a>00212     <span class="comment">/*</span>
<a name="l00213"></a>00213 <span class="comment">        NOTE (eberdahl@adobe.com): Because c_str is required to return a null-terminated sequence,</span>
<a name="l00214"></a>00214 <span class="comment">        we ensure that the storage vector is always null-terminated. This means that the storage</span>
<a name="l00215"></a>00215 <span class="comment">        is always either empty or contains one extra character to hold the null-character.</span>
<a name="l00216"></a>00216 <span class="comment">    */</span>
<a name="l00217"></a>00217     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;
<a name="l00218"></a>00218     <span class="keywordtype">void</span> <a class="code" href="structadobe_1_1assign.html">assign</a>(ForwardIterator first, ForwardIterator last, std::forward_iterator_tag)
<a name="l00219"></a>00219     {
<a name="l00220"></a>00220         <a class="code" href="classadobe_1_1version__1_1_1vector.html">storage_type</a> tmp;
<a name="l00221"></a>00221         <span class="keywordflow">if</span> (first != last)
<a name="l00222"></a>00222         {
<a name="l00223"></a>00223             <span class="keyword">const</span> <a class="code" href="classadobe_1_1version__1_1_1string__t.html#89a6dcafb6130e3e1bcd6d1285e0dd6f">size_type</a> len(<a class="code" href="group__adobe__iterator.html#g29c0de3eda3110fdb93572073fc56579">std::distance</a>(first, last));
<a name="l00224"></a>00224             tmp.<a class="code" href="classadobe_1_1version__1_1_1vector.html#562f7b24b47d3e7632a9896935c14d8b">reserve</a>(len + 1);
<a name="l00225"></a>00225             tmp.insert(tmp.<a class="code" href="classadobe_1_1version__1_1_1vector.html#cad38d52497a975bfb6f2f6acd76631f">end</a>(), first, last);
<a name="l00226"></a>00226             tmp.<a class="code" href="classadobe_1_1version__1_1_1vector.html#1a4ded38bf280cd2549689cac3ab4018">push_back</a>(<span class="keywordtype">char</span>(0));
<a name="l00227"></a>00227         }
<a name="l00228"></a>00228         storage_m.<a class="code" href="classadobe_1_1version__1_1_1vector.html#72f135082f0d4033fa5dbe3c2e27958f">swap</a>(tmp);
<a name="l00229"></a>00229     }
<a name="l00230"></a>00230 
<a name="l00231"></a>00231     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;
<a name="l00232"></a>00232     <span class="keywordtype">void</span> <a class="code" href="structadobe_1_1assign.html">assign</a>(InputIterator first, InputIterator last, std::input_iterator_tag)
<a name="l00233"></a>00233     {
<a name="l00234"></a>00234         storage_type tmp;
<a name="l00235"></a>00235         <span class="keywordflow">if</span> (first != last)
<a name="l00236"></a>00236         {
<a name="l00237"></a>00237             tmp.insert(tmp.end(), first, last);
<a name="l00238"></a>00238             tmp.push_back(<span class="keywordtype">char</span>(0));
<a name="l00239"></a>00239         }
<a name="l00240"></a>00240         storage_m.<a class="code" href="classadobe_1_1version__1_1_1vector.html#72f135082f0d4033fa5dbe3c2e27958f">swap</a>(tmp);
<a name="l00241"></a>00241     }
<a name="l00242"></a>00242 
<a name="l00243"></a>00243     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;
<a name="l00244"></a>00244     <span class="keywordtype">void</span> assign(Iterator first, Iterator last)
<a name="l00245"></a>00245     {
<a name="l00246"></a>00246         assign(first, last,
<a name="l00247"></a>00247                <span class="keyword">typename</span> std::iterator_traits&lt;Iterator&gt;::iterator_category());
<a name="l00248"></a>00248     }
<a name="l00249"></a>00249     
<a name="l00250"></a>00250  <span class="keyword">public</span>:
<a name="l00254"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#f06783ecbeb51e49478b02a36843b636">00254</a>     <a class="code" href="classadobe_1_1version__1_1_1string__t.html#f06783ecbeb51e49478b02a36843b636">string_t</a>() { }
<a name="l00255"></a>00255     
<a name="l00259"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#0f65cf073bcdf83de95501253db88604">00259</a>     <a class="code" href="classadobe_1_1version__1_1_1string__t.html#0f65cf073bcdf83de95501253db88604">string_t</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a>&amp; s) : storage_m(s.storage_m) { }
<a name="l00260"></a>00260     
<a name="l00264"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#579f64cb1bc56823ae121ec480d66386">00264</a>     <a class="code" href="classadobe_1_1version__1_1_1string__t.html#579f64cb1bc56823ae121ec480d66386">string_t</a>(<a class="code" href="structadobe_1_1move__from.html" title="move_from is used for move_ctors.">move_from&lt;string_t&gt;</a> x) : storage_m(<a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(x.source.storage_m)) { }
<a name="l00265"></a>00265 
<a name="l00271"></a>00271     <a class="code" href="classadobe_1_1version__1_1_1string__t.html#f06783ecbeb51e49478b02a36843b636">string_t</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* s);
<a name="l00272"></a>00272 
<a name="l00279"></a>00279     <a class="code" href="classadobe_1_1version__1_1_1string__t.html#f06783ecbeb51e49478b02a36843b636">string_t</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* s, std::size_t length);
<a name="l00280"></a>00280     
<a name="l00287"></a>00287     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;
<a name="l00288"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#06fba383b7c22f6533e6f4db07cecc8d">00288</a>     <a class="code" href="classadobe_1_1version__1_1_1string__t.html#f06783ecbeb51e49478b02a36843b636">string_t</a>(Iterator first, Iterator last)
<a name="l00289"></a>00289         { <a class="code" href="structadobe_1_1assign.html">assign</a>(first, last); }
<a name="l00290"></a>00290 
<a name="l00296"></a>00296     <a class="code" href="classadobe_1_1version__1_1_1string__t.html#f06783ecbeb51e49478b02a36843b636">string_t</a>(<span class="keyword">const</span> std::string&amp; s);
<a name="l00297"></a>00297     
<a name="l00301"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#90248541453b58c2c8f36d5a72c78f9e">00301</a>     <a class="code" href="classadobe_1_1version__1_1_1string__t.html#90248541453b58c2c8f36d5a72c78f9e">~string_t</a>() { }
<a name="l00302"></a>00302 
<a name="l00307"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#73bf6fb85c7cc357cc7b966623578e9d">00307</a>     <a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a>&amp; <a class="code" href="classadobe_1_1version__1_1_1string__t.html#73bf6fb85c7cc357cc7b966623578e9d">operator=</a>(<a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a> s) { storage_m = <a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(s.storage_m); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00308"></a>00308 
<a name="l00312"></a>00312     <span class="comment">/*</span>
<a name="l00313"></a>00313 <span class="comment">        NOTE (eberdahl@adobe.com): This function was created to support extracting std::string</span>
<a name="l00314"></a>00314 <span class="comment">        from any_regular_t (N.B. any_regular_t stores strings as string_t). Using conversion</span>
<a name="l00315"></a>00315 <span class="comment">        member functions may not be the best way to support the required conversion. Until</span>
<a name="l00316"></a>00316 <span class="comment">        any_regular_t changes the way it extracts data, we'll need this function.</span>
<a name="l00317"></a>00317 <span class="comment">     */</span>
<a name="l00318"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#7d27cc515e59f676f08d399124be099d">00318</a>     <a class="code" href="classadobe_1_1version__1_1_1string__t.html#7d27cc515e59f676f08d399124be099d">operator std::string</a>()<span class="keyword"> const</span>
<a name="l00319"></a>00319 <span class="keyword">        </span>{ <span class="keywordflow">return</span> std::string(<a class="code" href="classadobe_1_1version__1_1_1string__t.html#a4b02d4f1a8500fb07a551069060709f">begin</a>(), <a class="code" href="classadobe_1_1version__1_1_1string__t.html#350132543d80a1c1e5be844e6d2878ea">end</a>()); }
<a name="l00320"></a>00320     
<a name="l00325"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#89da6be964480b4c86334e4e337d3cf2">00325</a>     <span class="keyword">const</span> <span class="keywordtype">char</span>* c_str()<span class="keyword"> const</span>
<a name="l00326"></a>00326 <span class="keyword">        </span>{ <span class="keywordflow">return</span> empty() ? <span class="stringliteral">""</span> : &amp;storage_m[0]; }
<a name="l00327"></a>00327 
<a name="l00331"></a>00331     <span class="keywordtype">void</span> <a class="code" href="namespaceadobe_1_1version__1.html#1e0d6f8f7db07684fc6a35e93978db9f">push_back</a>(value_type c);
<a name="l00332"></a>00332 
<a name="l00336"></a>00336     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;
<a name="l00337"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#38e936b8de6c925272822b08ae32a6ae">00337</a>     <span class="keywordtype">void</span> append(Iterator first, Iterator last)
<a name="l00338"></a>00338     {
<a name="l00339"></a>00339         <span class="keywordflow">if</span> (first != last)
<a name="l00340"></a>00340         {
<a name="l00341"></a>00341             <span class="keywordflow">if</span> (!storage_m.empty())
<a name="l00342"></a>00342                 storage_m.pop_back();
<a name="l00343"></a>00343             
<a name="l00344"></a>00344             storage_m.insert(storage_m.end(), first, last);
<a name="l00345"></a>00345             storage_m.push_back(0);
<a name="l00346"></a>00346         }
<a name="l00347"></a>00347     }
<a name="l00348"></a>00348 
<a name="l00352"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#6cc9dca94534113f7d58fb2bb963e828">00352</a>     <span class="keywordtype">void</span> append(<span class="keyword">const</span> <a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a>&amp; s)
<a name="l00353"></a>00353         { <a class="code" href="classadobe_1_1version__1_1_1string__t.html#6cc9dca94534113f7d58fb2bb963e828">append</a>(s.<a class="code" href="classadobe_1_1version__1_1_1string__t.html#a4b02d4f1a8500fb07a551069060709f">begin</a>(), s.<a class="code" href="classadobe_1_1version__1_1_1string__t.html#350132543d80a1c1e5be844e6d2878ea">end</a>()); }
<a name="l00354"></a>00354 
<a name="l00358"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#5aef2117c36825289c1c266061336d06">00358</a>     <span class="keywordtype">void</span> append(<span class="keyword">const</span> <span class="keywordtype">char</span>* s)
<a name="l00359"></a>00359         { <a class="code" href="classadobe_1_1version__1_1_1string__t.html#5aef2117c36825289c1c266061336d06">append</a>(s, s + std::strlen(s)); }
<a name="l00360"></a>00360 
<a name="l00364"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#b6c630789e1c965eeebc88a3a3eec4f4">00364</a>     <span class="keywordtype">void</span> append(<span class="keyword">const</span> <span class="keywordtype">char</span>* s, std::size_t length)
<a name="l00365"></a>00365         { <a class="code" href="classadobe_1_1version__1_1_1string__t.html#b6c630789e1c965eeebc88a3a3eec4f4">append</a>(s, s + length); }
<a name="l00366"></a>00366 
<a name="l00370"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#92efe8f216f542e174158bccc7a74725">00370</a>     <span class="keywordtype">void</span> append(<span class="keyword">const</span> std::string&amp; s)
<a name="l00371"></a>00371         { <a class="code" href="classadobe_1_1version__1_1_1string__t.html#92efe8f216f542e174158bccc7a74725">append</a>(s.begin(), s.end()); }
<a name="l00372"></a>00372 
<a name="l00376"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#90c986c65e5a78a5a045e437f75e2818">00376</a>     <a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a>&amp; operator+=(<span class="keyword">const</span> <a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a>&amp; s)
<a name="l00377"></a>00377         { append(s); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00378"></a>00378     
<a name="l00382"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#2874efe5345a0f2b01fee2bd17edcd71">00382</a>     <a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a>&amp; operator+=(<span class="keyword">const</span> <span class="keywordtype">char</span>* s)
<a name="l00383"></a>00383         { append(s); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00384"></a>00384     
<a name="l00388"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#e192477b3d9bf17b68874119f6aa6903">00388</a>     <a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a>&amp; operator+=(<span class="keyword">const</span> std::string&amp; s)
<a name="l00389"></a>00389         { append(s); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00390"></a>00390     
<a name="l00394"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#a4b02d4f1a8500fb07a551069060709f">00394</a>     const_iterator begin()<span class="keyword"> const</span>
<a name="l00395"></a>00395 <span class="keyword">        </span>{ <span class="keywordflow">return</span> storage_m.begin(); }
<a name="l00396"></a>00396 
<a name="l00400"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#350132543d80a1c1e5be844e6d2878ea">00400</a>     const_iterator end()<span class="keyword"> const</span>
<a name="l00401"></a>00401 <span class="keyword">        </span>{ <span class="keywordflow">return</span> storage_m.empty() ? storage_m.end() : boost::prior(storage_m.end()); }
<a name="l00402"></a>00402 
<a name="l00406"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#04886aa70c34d66738e78bf70c675e66">00406</a>     const_reverse_iterator rbegin()<span class="keyword"> const</span>
<a name="l00407"></a>00407 <span class="keyword">        </span>{ <span class="keywordflow">return</span> const_reverse_iterator(end()); }
<a name="l00408"></a>00408 
<a name="l00412"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#b3c414470d5cea2986cfab7a90146cb6">00412</a>     const_reverse_iterator <a class="code" href="classadobe_1_1version__1_1_1string__t.html#b3c414470d5cea2986cfab7a90146cb6">rend</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> const_reverse_iterator(begin()); }
<a name="l00413"></a>00413 
<a name="l00418"></a>00418     size_type capacity() <span class="keyword">const</span>;
<a name="l00419"></a>00419     
<a name="l00425"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#562f7b24b47d3e7632a9896935c14d8b">00425</a>     <span class="keywordtype">void</span> reserve(size_type n)
<a name="l00426"></a>00426         { storage_m.reserve(0 == n ? 0 : n + 1); }
<a name="l00427"></a>00427 
<a name="l00431"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#c8bb3912a3ce86b15842e79d0b421204">00431</a>     <span class="keywordtype">void</span> <a class="code" href="group__sequence__view.html#ge86d3d95373ce0d9f1d92c9f62b58d14" title="SequenceView concept requirement.">clear</a>()
<a name="l00432"></a>00432         { storage_m.clear(); }
<a name="l00433"></a>00433     
<a name="l00437"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#503ab01f6c0142145d3434f6924714e7">00437</a>     size_type <a class="code" href="group__selection__algorithms.html#g7c5bdb55e42beda2cd6acbe643ef4fa2">size</a>()<span class="keyword"> const</span>
<a name="l00438"></a>00438 <span class="keyword">        </span>{ <span class="keywordflow">return</span> storage_m.empty() ? 0 : storage_m.size() - 1; }
<a name="l00439"></a>00439 
<a name="l00443"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#c6e61de369e994009e36f344f99c15ad">00443</a>     <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
<a name="l00444"></a>00444 <span class="keyword">        </span>{ <span class="keywordflow">return</span> storage_m.empty(); }
<a name="l00445"></a>00445 
<a name="l00449"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#41f244dc1775ff3de1356d0b53682bbe">00449</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceadobe.html#5c6656b2ba51d81c71a97670f3b15a83">swap</a>(<a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a>&amp; s)
<a name="l00450"></a>00450         { storage_m.swap(s.storage_m); }
<a name="l00451"></a>00451     
<a name="l00452"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#e1472c02ccf24d6791ef11d5d5cb16be">00452</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="group__abi__string.html#g7fc325d22b6836144772f54fc798c56b">operator==</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a>&amp; y)
<a name="l00453"></a>00453     {
<a name="l00454"></a>00454         <span class="keywordflow">return</span> x.storage_m == y.storage_m;
<a name="l00455"></a>00455     }
<a name="l00456"></a>00456 
<a name="l00457"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#e8ce3ce5a2e732e24a9f3112aa9fdf53">00457</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="group__abi__string.html#g8e3984ca7eb04e400a9b0549b9d3ab1e">operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a>&amp; y)
<a name="l00458"></a>00458     {
<a name="l00459"></a>00459         <span class="keywordflow">return</span> x.storage_m &lt; y.storage_m;
<a name="l00460"></a>00460     }
<a name="l00461"></a>00461     
<a name="l00462"></a><a class="code" href="classadobe_1_1version__1_1_1string__t.html#d34b9fc551ab8c53b69e2249a9afa1c5">00462</a>     <span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespaceadobe.html#5c6656b2ba51d81c71a97670f3b15a83">swap</a>(<a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a>&amp; x, <a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a>&amp; y)
<a name="l00463"></a>00463         { x.storage_m.<a class="code" href="classadobe_1_1version__1_1_1vector.html#72f135082f0d4033fa5dbe3c2e27958f">swap</a>(y.storage_m); }
<a name="l00464"></a>00464 };
<a name="l00465"></a>00465 
<a name="l00471"></a><a class="code" href="namespaceadobe_1_1version__1.html#163d10ab817297db0286db6620ce0234">00471</a> <span class="keyword">inline</span> <a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a> <a class="code" href="namespaceadobe_1_1version__1.html#163d10ab817297db0286db6620ce0234">operator+</a>(<a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a> s1, <span class="keyword">const</span> <a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a>&amp; s2)     { <span class="keywordflow">return</span> <a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(s1 += s2); }
<a name="l00472"></a><a class="code" href="namespaceadobe_1_1version__1.html#bae90c7a10a718c34c948ba92d259b94">00472</a> <span class="keyword">inline</span> <a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a> <a class="code" href="namespaceadobe_1_1version__1.html#163d10ab817297db0286db6620ce0234">operator+</a>(<a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a> s1, <span class="keyword">const</span> std::string&amp; s2)  { <span class="keywordflow">return</span> <a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(s1 += s2); }
<a name="l00473"></a><a class="code" href="namespaceadobe_1_1version__1.html#7360f1c728fd7bff0fb0bf2db3aa074c">00473</a> <span class="keyword">inline</span> <a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a> <a class="code" href="namespaceadobe_1_1version__1.html#163d10ab817297db0286db6620ce0234">operator+</a>(<a class="code" href="classadobe_1_1version__1_1_1string__t.html">string_t</a> s1, <span class="keyword">const</span> <span class="keywordtype">char</span>* s2)         { <span class="keywordflow">return</span> <a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(s1 += s2); }
<a name="l00474"></a>00474 
<a name="l00475"></a>00475 <span class="comment">/*************************************************************************************************/</span>
<a name="l00476"></a>00476 
<a name="l00477"></a>00477 <span class="preprocessor">#if defined(ADOBE_STD_SERIALIZATION)</span>
<a name="l00478"></a>00478 <span class="preprocessor"></span>std::ostream&amp; <a class="code" href="namespaceadobe.html#ea1bfd7201458bb8732897793ca8466d">operator&lt;&lt;</a>(std::ostream&amp; os, <span class="keyword">const</span> <a class="code" href="classadobe_1_1string__t.html" title="Lightweight string class designed to hold UTF8 strings in fixed binary structure...">string_t</a>&amp; t);
<a name="l00479"></a>00479 <span class="preprocessor">#endif</span>
<a name="l00480"></a>00480 <span class="preprocessor"></span>
<a name="l00481"></a>00481 <span class="comment">/*************************************************************************************************/</span>
<a name="l00482"></a>00482 
<a name="l00493"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html">00493</a> <span class="keyword">class </span><a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a> : boost::<a class="code" href="classboost_1_1totally__ordered.html">totally_ordered</a>&lt;string16_t, string16_t, empty_base_t&lt;string16_t&gt; &gt;
<a name="l00494"></a>00494 {
<a name="l00495"></a>00495 <span class="keyword">public</span>:
<a name="l00496"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#87c0271ba953adfe53b90264a7a16acf">00496</a>     <span class="keyword">typedef</span> boost::uint16_t                               value_type;
<a name="l00497"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#5c9034c2f7296101f502a263da441345">00497</a>     <span class="keyword">typedef</span> boost::uint16_t*                              pointer;
<a name="l00498"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#33daf527895e50855180af1622711d87">00498</a>     <span class="keyword">typedef</span> <span class="keyword">const</span> boost::uint16_t*                        const_pointer;
<a name="l00499"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#682ee4b91266e4d1555cb6767392f4cb">00499</a>     <span class="keyword">typedef</span> boost::uint16_t&amp;                              reference;
<a name="l00500"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#f8d74d9cc8c9340e6234361c933c03e4">00500</a>     <span class="keyword">typedef</span> <span class="keyword">const</span> boost::uint16_t&amp;                        const_reference;
<a name="l00501"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#89a6dcafb6130e3e1bcd6d1285e0dd6f">00501</a>     <span class="keyword">typedef</span> std::size_t                                   size_type;
<a name="l00502"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#d319fc54a93a2c7058c70e40428ed2e2">00502</a>     <span class="keyword">typedef</span> std::ptrdiff_t                                difference_type;
<a name="l00503"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#bafae76c29ddd34c14529057d2c52d78">00503</a>     <span class="keyword">typedef</span> boost::uint16_t*                              iterator;
<a name="l00504"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#10a77e2383bd6f5150257c3a00de6299">00504</a>     <span class="keyword">typedef</span> <span class="keyword">const</span> boost::uint16_t*                        const_iterator;
<a name="l00505"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#6e8bd3e20a8ab7ef32e330be563f285c">00505</a>     <span class="keyword">typedef</span> std::reverse_iterator&lt;boost::uint16_t*&gt;       reverse_iterator;
<a name="l00506"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#c1ed3cda6adddd73396603099e20dd27">00506</a>     <span class="keyword">typedef</span> std::reverse_iterator&lt;const boost::uint16_t*&gt; const_reverse_iterator;
<a name="l00507"></a>00507     
<a name="l00508"></a>00508 <span class="keyword">private</span>:
<a name="l00509"></a>00509     <span class="keyword">typedef</span> <a class="code" href="classadobe_1_1version__1_1_1vector.html">vector&lt;value_type&gt;</a>                            <a class="code" href="classadobe_1_1version__1_1_1vector.html">storage_type</a>;
<a name="l00510"></a>00510 
<a name="l00511"></a>00511     <a class="code" href="classadobe_1_1version__1_1_1vector.html">storage_type</a> storage_m;
<a name="l00512"></a>00512     
<a name="l00513"></a>00513     <span class="comment">/*</span>
<a name="l00514"></a>00514 <span class="comment">        NOTE (eberdahl@adobe.com): Because c_str is required to return a null-terminated sequence,</span>
<a name="l00515"></a>00515 <span class="comment">        we ensure that the storage vector is always null-terminated. This means that the storage</span>
<a name="l00516"></a>00516 <span class="comment">        is always either empty or contains one extra character to hold the null-character.</span>
<a name="l00517"></a>00517 <span class="comment">     */</span>
<a name="l00518"></a>00518     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator&gt;
<a name="l00519"></a>00519     <span class="keywordtype">void</span> <a class="code" href="structadobe_1_1assign.html">assign</a>(ForwardIterator first, ForwardIterator last, std::forward_iterator_tag)
<a name="l00520"></a>00520     {
<a name="l00521"></a>00521         <a class="code" href="classadobe_1_1version__1_1_1vector.html">storage_type</a> tmp;
<a name="l00522"></a>00522         <span class="keywordflow">if</span> (first != last)
<a name="l00523"></a>00523         {
<a name="l00524"></a>00524             <span class="keyword">const</span> size_type len(<a class="code" href="group__adobe__iterator.html#g29c0de3eda3110fdb93572073fc56579">std::distance</a>(first, last));
<a name="l00525"></a>00525             tmp.<a class="code" href="classadobe_1_1version__1_1_1vector.html#562f7b24b47d3e7632a9896935c14d8b">reserve</a>(len + 1);
<a name="l00526"></a>00526             tmp.insert(tmp.<a class="code" href="classadobe_1_1version__1_1_1vector.html#cad38d52497a975bfb6f2f6acd76631f">end</a>(), first, last);
<a name="l00527"></a>00527             tmp.<a class="code" href="classadobe_1_1version__1_1_1vector.html#1a4ded38bf280cd2549689cac3ab4018">push_back</a>(boost::uint16_t(0));
<a name="l00528"></a>00528         }
<a name="l00529"></a>00529         storage_m.swap(tmp);
<a name="l00530"></a>00530     }
<a name="l00531"></a>00531     
<a name="l00532"></a>00532     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;
<a name="l00533"></a>00533     <span class="keywordtype">void</span> <a class="code" href="structadobe_1_1assign.html">assign</a>(InputIterator first, InputIterator last, std::input_iterator_tag)
<a name="l00534"></a>00534     {
<a name="l00535"></a>00535         storage_type tmp;
<a name="l00536"></a>00536         <span class="keywordflow">if</span> (first != last)
<a name="l00537"></a>00537         {
<a name="l00538"></a>00538             tmp.insert(tmp.end(), first, last);
<a name="l00539"></a>00539             tmp.push_back(boost::uint16_t(0));
<a name="l00540"></a>00540         }
<a name="l00541"></a>00541         storage_m.swap(tmp);
<a name="l00542"></a>00542     }
<a name="l00543"></a>00543     
<a name="l00544"></a>00544     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;
<a name="l00545"></a>00545     <span class="keywordtype">void</span> assign(Iterator first, Iterator last)
<a name="l00546"></a>00546     {
<a name="l00547"></a>00547         assign(first, last,
<a name="l00548"></a>00548                <span class="keyword">typename</span> std::iterator_traits&lt;Iterator&gt;::iterator_category());
<a name="l00549"></a>00549     }
<a name="l00550"></a>00550     
<a name="l00551"></a>00551 <span class="keyword">public</span>:
<a name="l00555"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#cd28357b1e697ea119a1b82a6a1d7312">00555</a>     <a class="code" href="classadobe_1_1version__1_1_1string16__t.html#cd28357b1e697ea119a1b82a6a1d7312">string16_t</a>() { }
<a name="l00556"></a>00556     
<a name="l00560"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#bc5344cb1575ac7bccad438e6c3d24ad">00560</a>     <a class="code" href="classadobe_1_1version__1_1_1string16__t.html#bc5344cb1575ac7bccad438e6c3d24ad">string16_t</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a>&amp; s) : storage_m(s.storage_m) { }
<a name="l00561"></a>00561 
<a name="l00565"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#bb5ebf6686b41672073287705662ccfe">00565</a>     <a class="code" href="classadobe_1_1version__1_1_1string16__t.html#bb5ebf6686b41672073287705662ccfe">string16_t</a>(<a class="code" href="structadobe_1_1move__from.html" title="move_from is used for move_ctors.">move_from&lt;string16_t&gt;</a> x) : storage_m(<a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(x.source.storage_m)) { }
<a name="l00566"></a>00566 
<a name="l00572"></a>00572     <a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a>(<span class="keyword">const</span> boost::uint16_t* s);
<a name="l00573"></a>00573 
<a name="l00580"></a>00580     <a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a>(<span class="keyword">const</span> boost::uint16_t* s, std::size_t length);
<a name="l00581"></a>00581     
<a name="l00588"></a>00588     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;
<a name="l00589"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#769d61ec4a6f721e392b1b717e2fdaca">00589</a>     <a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a>(Iterator first, Iterator last)
<a name="l00590"></a>00590         { <a class="code" href="structadobe_1_1assign.html">assign</a>(first, last); }
<a name="l00591"></a>00591 
<a name="l00595"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#0da72a25828ede51ab95bd8b18d115bb">00595</a>     <a class="code" href="classadobe_1_1version__1_1_1string16__t.html#0da72a25828ede51ab95bd8b18d115bb">~string16_t</a>() { }
<a name="l00596"></a>00596     
<a name="l00600"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#7624b8262db030c7d640d0694f91ff72">00600</a>     <a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a>&amp; operator=(<a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a> s)
<a name="l00601"></a>00601         { storage_m = <a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(s.storage_m); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00602"></a>00602     
<a name="l00607"></a>00607     <span class="keyword">const</span> boost::uint16_t* c_str() <span class="keyword">const</span>;
<a name="l00608"></a>00608     
<a name="l00612"></a>00612     <span class="keywordtype">void</span> <a class="code" href="group__sequence__model__concept.html#g645608d6e199d8a1ac169225b79b791e" title="SequenceModel concept requirement.">push_back</a>(value_type c);
<a name="l00613"></a>00613     
<a name="l00617"></a>00617     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;
<a name="l00618"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#38e936b8de6c925272822b08ae32a6ae">00618</a>     <span class="keywordtype">void</span> append(Iterator first, Iterator last)
<a name="l00619"></a>00619     {
<a name="l00620"></a>00620         <span class="keywordflow">if</span> (first != last)
<a name="l00621"></a>00621         {
<a name="l00622"></a>00622             <span class="keywordflow">if</span> (!storage_m.empty())
<a name="l00623"></a>00623                 storage_m.pop_back();
<a name="l00624"></a>00624             
<a name="l00625"></a>00625             storage_m.insert(storage_m.end(), first, last);
<a name="l00626"></a>00626             storage_m.push_back(0);
<a name="l00627"></a>00627         }
<a name="l00628"></a>00628     }
<a name="l00629"></a>00629     
<a name="l00633"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#b8aa0089ca326748f931c58cae2cd497">00633</a>     <span class="keywordtype">void</span> append(<span class="keyword">const</span> <a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a>&amp; s)
<a name="l00634"></a>00634         { <a class="code" href="classadobe_1_1version__1_1_1string16__t.html#b8aa0089ca326748f931c58cae2cd497">append</a>(s.<a class="code" href="classadobe_1_1version__1_1_1string16__t.html#a4b02d4f1a8500fb07a551069060709f">begin</a>(), s.<a class="code" href="classadobe_1_1version__1_1_1string16__t.html#350132543d80a1c1e5be844e6d2878ea">end</a>()); }
<a name="l00635"></a>00635     
<a name="l00639"></a>00639     <span class="keywordtype">void</span> append(<span class="keyword">const</span> boost::uint16_t* s);
<a name="l00640"></a>00640     
<a name="l00644"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#a641f4cbeefe6c51cbbdeaa9411a77a9">00644</a>     <span class="keywordtype">void</span> append(<span class="keyword">const</span> boost::uint16_t* s, std::size_t length)
<a name="l00645"></a>00645         { <a class="code" href="classadobe_1_1version__1_1_1string16__t.html#a641f4cbeefe6c51cbbdeaa9411a77a9">append</a>(s, s + length); }
<a name="l00646"></a>00646     
<a name="l00650"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#c0101919e80292f46a923e2369c9fa26">00650</a>     <a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a>&amp; operator+=(<span class="keyword">const</span> <a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a>&amp; s)
<a name="l00651"></a>00651         { append(s); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00652"></a>00652     
<a name="l00656"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#0e5333ed3674214c022b89c577201dc5">00656</a>     <a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a>&amp; operator+=(<span class="keyword">const</span> boost::uint16_t* s)
<a name="l00657"></a>00657         { append(s); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00658"></a>00658     
<a name="l00662"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#a4b02d4f1a8500fb07a551069060709f">00662</a>     const_iterator begin()<span class="keyword"> const</span>
<a name="l00663"></a>00663 <span class="keyword">        </span>{ <span class="keywordflow">return</span> storage_m.begin(); }
<a name="l00664"></a>00664     
<a name="l00668"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#350132543d80a1c1e5be844e6d2878ea">00668</a>     const_iterator end()<span class="keyword"> const</span>
<a name="l00669"></a>00669 <span class="keyword">        </span>{ <span class="keywordflow">return</span> storage_m.empty() ? storage_m.end() : boost::prior(storage_m.end()); }
<a name="l00670"></a>00670     
<a name="l00674"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#04886aa70c34d66738e78bf70c675e66">00674</a>     const_reverse_iterator rbegin()<span class="keyword"> const</span>
<a name="l00675"></a>00675 <span class="keyword">        </span>{ <span class="keywordflow">return</span> const_reverse_iterator(end()); }
<a name="l00676"></a>00676     
<a name="l00680"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#b3c414470d5cea2986cfab7a90146cb6">00680</a>     const_reverse_iterator rend()<span class="keyword"> const</span>
<a name="l00681"></a>00681 <span class="keyword">        </span>{ <span class="keywordflow">return</span> const_reverse_iterator(begin()); }
<a name="l00682"></a>00682     
<a name="l00687"></a>00687     size_type capacity() <span class="keyword">const</span>;
<a name="l00688"></a>00688     
<a name="l00694"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#562f7b24b47d3e7632a9896935c14d8b">00694</a>     <span class="keywordtype">void</span> reserve(size_type n)
<a name="l00695"></a>00695         { storage_m.reserve(0 == n ? 0 : n + 1); }
<a name="l00696"></a>00696     
<a name="l00700"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#c8bb3912a3ce86b15842e79d0b421204">00700</a>     <span class="keywordtype">void</span> <a class="code" href="group__sequence__view.html#ge86d3d95373ce0d9f1d92c9f62b58d14" title="SequenceView concept requirement.">clear</a>()
<a name="l00701"></a>00701         { storage_m.clear(); }
<a name="l00702"></a>00702     
<a name="l00706"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#503ab01f6c0142145d3434f6924714e7">00706</a>     size_type <a class="code" href="group__selection__algorithms.html#g7c5bdb55e42beda2cd6acbe643ef4fa2">size</a>()<span class="keyword"> const</span>
<a name="l00707"></a>00707 <span class="keyword">        </span>{ <span class="keywordflow">return</span> storage_m.empty() ? 0 : storage_m.size() - 1; }
<a name="l00708"></a>00708     
<a name="l00712"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#c6e61de369e994009e36f344f99c15ad">00712</a>     <span class="keywordtype">bool</span> empty()<span class="keyword"> const</span>
<a name="l00713"></a>00713 <span class="keyword">        </span>{ <span class="keywordflow">return</span> storage_m.empty(); }
<a name="l00714"></a>00714     
<a name="l00718"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#fb8522e6f4f588d40a5316f0040afc80">00718</a>     <span class="keywordtype">void</span> <a class="code" href="namespaceadobe.html#5c6656b2ba51d81c71a97670f3b15a83">swap</a>(<a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a>&amp; s)
<a name="l00719"></a>00719         { storage_m.swap(s.storage_m); }
<a name="l00720"></a>00720     
<a name="l00721"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#85999250ca1e5d879261d5586d9fc024">00721</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespaceadobe.html#a70510cd533bc8e226d58fc472ca1f6b">operator==</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a>&amp; y)
<a name="l00722"></a>00722     {
<a name="l00723"></a>00723         <span class="keywordflow">return</span> x.storage_m == y.storage_m;
<a name="l00724"></a>00724     }
<a name="l00725"></a>00725     
<a name="l00726"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#d81f7d803b6ccd5f1420dfb72ec05c69">00726</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="group__adobe__iterator.html#gd7d15ca155374c36024159d745e9d8fe">operator&lt;</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a>&amp; y)
<a name="l00727"></a>00727     {
<a name="l00728"></a>00728         <span class="keywordflow">return</span> x.storage_m &lt; y.storage_m;
<a name="l00729"></a>00729     }
<a name="l00730"></a>00730     
<a name="l00731"></a><a class="code" href="classadobe_1_1version__1_1_1string16__t.html#f598604c0f7feedb07cb63f19e3afd35">00731</a>     <span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classadobe_1_1version__1_1_1string16__t.html#f598604c0f7feedb07cb63f19e3afd35">swap</a>(<a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a>&amp; x, <a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a>&amp; y) { x.storage_m.<a class="code" href="classadobe_1_1version__1_1_1vector.html#72f135082f0d4033fa5dbe3c2e27958f">swap</a>(y.storage_m); }
<a name="l00732"></a>00732 };
<a name="l00733"></a>00733 
<a name="l00740"></a><a class="code" href="namespaceadobe_1_1version__1.html#d44f9db5b17921cfd2949bc46251f589">00740</a> <span class="keyword">inline</span> <a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a> <a class="code" href="namespaceadobe_1_1version__1.html#163d10ab817297db0286db6620ce0234">operator+</a>(<a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a> s1, <span class="keyword">const</span> <a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a>&amp; s2)      { <span class="keywordflow">return</span> <a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(s1 += s2); }
<a name="l00741"></a><a class="code" href="namespaceadobe_1_1version__1.html#97b08a870af25a00a03ffeb2276b4251">00741</a> <span class="keyword">inline</span> <a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a> <a class="code" href="namespaceadobe_1_1version__1.html#163d10ab817297db0286db6620ce0234">operator+</a>(<a class="code" href="classadobe_1_1version__1_1_1string16__t.html">string16_t</a> s1, <span class="keyword">const</span> boost::uint16_t* s2) { <span class="keywordflow">return</span> <a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(s1 += s2); }
<a name="l00742"></a>00742 
<a name="l00744"></a>00744 
<a name="l00745"></a>00745 <span class="comment">/*************************************************************************************************/</span>
<a name="l00746"></a>00746 
<a name="l00747"></a>00747 <a class="code" href="namespaceadobe.html#0d19002ca08b6fc1baf4fad3522925c3">BOOST_STATIC_ASSERT</a>(<span class="keyword">sizeof</span>(<a class="code" href="classadobe_1_1string__t.html" title="Lightweight string class designed to hold UTF8 strings in fixed binary structure...">string_t</a>) == <span class="keyword">sizeof</span>(vector&lt;char&gt;));
<a name="l00748"></a>00748 <a class="code" href="namespaceadobe.html#0d19002ca08b6fc1baf4fad3522925c3">BOOST_STATIC_ASSERT</a>(<span class="keyword">sizeof</span>(<a class="code" href="classadobe_1_1string16__t.html" title="Lightweight string class designed to hold UTF16 strings in fixed binary structure...">string16_t</a>) == <span class="keyword">sizeof</span>(vector&lt;boost::uint16_t&gt;));
<a name="l00749"></a>00749 
<a name="l00750"></a>00750 <span class="comment">/*************************************************************************************************/</span>
<a name="l00751"></a>00751 
<a name="l00752"></a>00752 } <span class="comment">// namespace version_1</span>
<a name="l00753"></a>00753 
<a name="l00754"></a>00754 <span class="comment">/*************************************************************************************************/</span>
<a name="l00755"></a>00755 
<a name="l00756"></a>00756 <span class="keyword">using</span> version_1::string_t;
<a name="l00757"></a>00757 <span class="keyword">using</span> version_1::string16_t;
<a name="l00758"></a>00758 
<a name="l00759"></a>00759 <span class="comment">/*************************************************************************************************/</span>
<a name="l00760"></a>00760 
<a name="l00761"></a>00761 } <span class="comment">// namespace adobe</span>
<a name="l00762"></a>00762 
<a name="l00763"></a>00763 <span class="comment">/*************************************************************************************************/</span>
<a name="l00764"></a>00764 
<a name="l00765"></a>00765 <a class="code" href="group__type__info__related.html#g463022386b71e84faebf955a57f41898" title="Register a type for use with manual adobe::version_1::type_info_t . This integer...">ADOBE_NAME_TYPE_0</a>(<span class="stringliteral">"string_t:version_1:adobe"</span>, <a class="code" href="classadobe_1_1version__1_1_1string__t.html">adobe::version_1::string_t</a>)
<a name="l00766"></a>00766 <a class="code" href="group__type__info__related.html#g463022386b71e84faebf955a57f41898" title="Register a type for use with manual adobe::version_1::type_info_t . This integer...">ADOBE_NAME_TYPE_0</a>("string16_t:version_1:adobe", adobe::version_1::string16_t)
<a name="l00767"></a>00767 
<a name="l00768"></a>00768 <a class="code" href="typeinfo_8hpp.html#2c9c665e862a52f2eb44cc05dadf14e5">ADOBE_SHORT_NAME_TYPE</a>('s','t','r','g', adobe::version_1::string_t)
<a name="l00769"></a>00769 <a class="code" href="typeinfo_8hpp.html#2c9c665e862a52f2eb44cc05dadf14e5">ADOBE_SHORT_NAME_TYPE</a>('s','t','1','6', adobe::version_1::string16_t)
<a name="l00770"></a>00770 
<a name="l00771"></a>00771 <span class="comment">/*************************************************************************************************/</span>
<a name="l00772"></a>00772 
<a name="l00773"></a>00773 namespace boost {
<a name="l00774"></a>00774 
<a name="l00775"></a>00775 <span class="keyword">template</span> &lt;&gt;
<a name="l00776"></a><a class="code" href="structboost_1_1has__nothrow__constructor_3_01adobe_1_1version__1_1_1string__t_01_4.html">00776</a> <span class="keyword">struct </span>has_nothrow_constructor&lt;adobe::version_1::string_t&gt; : boost::mpl::true_ { };
<a name="l00777"></a>00777 
<a name="l00778"></a>00778 <span class="keyword">template</span> &lt;&gt;
<a name="l00779"></a><a class="code" href="structboost_1_1has__nothrow__constructor_3_01adobe_1_1version__1_1_1string16__t_01_4.html">00779</a> <span class="keyword">struct </span>has_nothrow_constructor&lt;adobe::version_1::string16_t&gt; : boost::mpl::true_ { };
<a name="l00780"></a>00780 
<a name="l00781"></a>00781 } <span class="comment">// namespace boost</span>
<a name="l00782"></a>00782 
<a name="l00783"></a>00783 <span class="comment">/*************************************************************************************************/</span>
<a name="l00784"></a>00784 
<a name="l00785"></a>00785 <span class="preprocessor">#endif</span>
<a name="l00786"></a>00786 <span class="preprocessor"></span>
<a name="l00787"></a>00787 <span class="comment">/*************************************************************************************************/</span>
</pre></div></div>

<!-- Begin Footer -->
</td></tr>
</table>
</div> <!-- content -->
<div class='footerdiv'>
    <div id='footersub'>
        <ul>
            <li><a href="http://www.adobe.com/go/gftray_foot_aboutadobe">Company</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_contact_adobe">Contact Us</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_accessibility">Accessibility</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_report_piracy">Report Piracy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_permissions_trademarks">Permissions &amp; Trademarks</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_product_license_agreements">Product License Agreements</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_feedback">Send Feedback</a></li>
        </ul>
        <div>
            <p>Copyright &#169; 2006-2007 Adobe Systems Incorporated.</p>
            <p>Use of this website signifies your agreement to the <a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a> and <a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>.</p>
            <p>Search powered by <a href="http://www.google.com/" target="new">Google</a></p>
        </div>
	</div>
</div>
<script type="text/javascript">
_uacct = "UA-396569-1";
urchinTracker();
</script>
</body>
</html>
