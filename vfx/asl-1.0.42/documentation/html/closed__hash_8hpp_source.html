<!--
    Copyright 2005-2008 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <TITLE>Adobe Software Technology Lab: closed_hash.hpp Source File</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="stlab.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
</head>
<body>
<div id='content'>
<table><tr>
<td colspan='5'>
    <div id='opensource_banner'>
    <table style='width: 100%; padding: 5px;'><tr>
    <td align='left'>
        <a href='index.html' style='border: none'><img src='stlab2007.jpg' alt="stlab.adobe.com"/></a>
    </td>
    <td align='right'>
        <a href='http://www.adobe.com' style='border: none'><img src='adobe_hlogo.gif' alt="Adobe Systems Incorporated"/></a>
    </td>
    </tr></table>
    </div>
</td></tr><tr>
<td valign="top">
    <div id='navtable' height='100%'>
    <div style='margin: 5px'>
        <h4>Documentation</h4>

        <a href="group__asl__overview.html">Overview</a><br/>
        <a href="asl_readme.html">Building ASL</a><br/>
        <a href="asl_toc.html">Documentation</a><br/>
        <a href="http://stlab.adobe.com/wiki/index.php/Supplementary_ASL_Documentation">Library Wiki Docs</a><br/>
        <a href="asl_indices.html">Indices</a><br/>
        <a href="http://stlab.adobe.com/perforce/">Browse Perforce</a><br/>

        <h4>More Info</h4>

        <a href="asl_release_notes.html">Release Notes</a><br/>
        <a href="http://stlab.adobe.com/wiki/">Wiki</a><br/>
        <a href="asl_search.html">Site Search</a><br/>
        <a href="licenses.html">License</a><br/>
        <a href="success_stories.html">Success Stories</a><br/>
        <a href="asl_contributors.html">Contributors</a><br/>

        <h4>Media</h4>

        <a href="http://sourceforge.net/project/showfiles.php?group_id=132417&amp;package_id=145420">Download</a><br/>
        <a href="asl_download_perforce.html">Perforce Depots</a><br/>

        <h4>Support</h4>

        <a href="http://sourceforge.net/projects/adobe-source/">ASL SourceForge Home</a><br/>
        <a href="http://sourceforge.net/mail/?group_id=132417">Mailing Lists</a><br/>
        <a href="http://sourceforge.net/forum/?group_id=132417">Discussion Forums</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724218&amp;group_id=132417&amp;func=browse">Report Bugs</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724221&amp;group_id=132417&amp;func=browse">Suggest Features</a><br/>
        <a href="asl_contributing.html">Contribute to ASL</a><br/>

        <h4>RSS</h4>

        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417">Short-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1">Full-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projfiles.php?group_id=132417">File releases</a><br/>

        <h4>Other Adobe Projects</h4>

        <a href="adobe_apollo.html">Adobe Air</a><br/>
        <a href="http://stlab.adobe.com/gil/">Adobe GIL</a><br/>
        <a href="http://stlab.adobe.com/performance/">C++ Benchmarks</a><br/>
        <a href="http://labs.adobe.com">Adobe Labs</a><br/>
        <a href="http://stlab.adobe.com/amg/">Adobe Media Gallery</a><br/>
        <a href="http://www.adobe.com/products/xmp/">Adobe XMP</a><br/>
        <a href="http://www.mozilla.org/projects/tamarin">Tamarin project<br/>(Mozilla Foundation)</a><br/>

        <h4>Other Resources</h4>

        <a href="http://boost.org">Boost</a><br/>
        <a href="http://www.riaforge.com/">RIAForge</a><br/>
        <a href="http://www.sgi.com/tech/stl">SGI STL</a><br/>
    </div>
    </div>
</td>
<td id='maintable' width="100%" valign="top">

<!-- End Header -->
<!-- Generated by Doxygen 1.5.9 -->
<h1>closed_hash.hpp</h1><a href="closed__hash_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">    Copyright 2005-2007 Adobe Systems Incorporated</span>
<a name="l00003"></a>00003 <span class="comment">    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt</span>
<a name="l00004"></a>00004 <span class="comment">    or a copy at http://stlab.adobe.com/licenses.html)</span>
<a name="l00005"></a>00005 <span class="comment">*/</span>
<a name="l00006"></a>00006 
<a name="l00007"></a>00007 <span class="comment">/*************************************************************************************************/</span>
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="preprocessor">#ifndef ADOBE_CLOSED_HASH_HPP</span>
<a name="l00010"></a>00010 <span class="preprocessor"></span><span class="preprocessor">#define ADOBE_CLOSED_HASH_HPP</span>
<a name="l00011"></a>00011 <span class="preprocessor"></span>
<a name="l00012"></a>00012 <span class="comment">/*************************************************************************************************/</span>
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="preprocessor">#include &lt;<a class="code" href="config_8hpp.html">adobe/config.hpp</a>&gt;</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;<a class="code" href="closed__hash__fwd_8hpp.html">adobe/closed_hash_fwd.hpp</a>&gt;</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;climits&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;cstddef&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;boost/compressed_pair.hpp&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;boost/functional/hash.hpp&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;boost/iterator/iterator_adaptor.hpp&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;boost/iterator/iterator_facade.hpp&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;boost/static_assert.hpp&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;boost/type_traits/has_nothrow_constructor.hpp&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;boost/type_traits/remove_reference.hpp&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;boost/operators.hpp&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;boost/next_prior.hpp&gt;</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;<a class="code" href="lower__bound_8hpp.html">adobe/algorithm/lower_bound.hpp</a>&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;<a class="code" href="conversion_8hpp.html">adobe/conversion.hpp</a>&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;<a class="code" href="cstdint_8hpp.html">adobe/cstdint.hpp</a>&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;<a class="code" href="empty_8hpp.html">adobe/empty.hpp</a>&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;<a class="code" href="functional_8hpp.html">adobe/functional.hpp</a>&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;<a class="code" href="set__next_8hpp.html">adobe/iterator/set_next.hpp</a>&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;<a class="code" href="memory_8hpp.html">adobe/memory.hpp</a>&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;<a class="code" href="move_8hpp.html">adobe/move.hpp</a>&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;<a class="code" href="utility_8hpp.html">adobe/utility.hpp</a>&gt;</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;adobe/implementation/swap.hpp&gt;</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="comment">/*************************************************************************************************/</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="keyword">namespace </span>adobe {
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="comment">/*************************************************************************************************/</span>
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="keyword">namespace </span>implementation {
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="comment">/*************************************************************************************************/</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> V&gt; <span class="comment">// V is value_type(T) const qualified</span>
<a name="l00055"></a>00055 <span class="keyword">class </span>closed_hash_iterator : <span class="keyword">public</span> boost::iterator_facade&lt;closed_hash_iterator&lt;T, V&gt;, V,
<a name="l00056"></a>00056                                                            std::bidirectional_iterator_tag&gt;
<a name="l00057"></a>00057 {
<a name="l00058"></a>00058     <span class="keyword">typedef</span> boost::iterator_facade&lt;closed_hash_iterator&lt;T, V&gt;, V,
<a name="l00059"></a>00059                                    std::bidirectional_iterator_tag&gt; inherited_t;
<a name="l00060"></a>00060 
<a name="l00061"></a>00061     <span class="keyword">typedef</span> <span class="keyword">typename</span> T::node_t node_t;
<a name="l00062"></a>00062  <span class="keyword">public</span>:
<a name="l00063"></a>00063     <span class="keyword">typedef</span> <span class="keyword">typename</span> inherited_t::reference         reference;
<a name="l00064"></a>00064     <span class="keyword">typedef</span> <span class="keyword">typename</span> inherited_t::difference_type   difference_type;
<a name="l00065"></a>00065     <span class="keyword">typedef</span> <span class="keyword">typename</span> inherited_t::value_type        value_type;
<a name="l00066"></a>00066 
<a name="l00067"></a>00067     closed_hash_iterator() : node_m(0) { }
<a name="l00068"></a>00068 
<a name="l00069"></a>00069     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> O&gt;
<a name="l00070"></a>00070     closed_hash_iterator(<span class="keyword">const</span> closed_hash_iterator&lt;T, O&gt;&amp; x) : node_m(x.node_m) { }
<a name="l00071"></a>00071 
<a name="l00072"></a>00072  <span class="keyword">public</span>:
<a name="l00073"></a>00073     <span class="comment">/*</span>
<a name="l00074"></a>00074 <span class="comment">        REVISIT (sparent@adobe.com) : node_m should be private but</span>
<a name="l00075"></a>00075 <span class="comment">        "gcc version 4.0.1 (Apple Inc. build 5465)" doesn't like it.</span>
<a name="l00076"></a>00076 <span class="comment">    */</span>
<a name="l00077"></a>00077 
<a name="l00078"></a>00078     node_t* node_m;
<a name="l00079"></a>00079 
<a name="l00080"></a>00080  <span class="keyword">private</span>:
<a name="l00081"></a>00081     
<a name="l00082"></a>00082     reference dereference()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> node_m-&gt;value_m; }
<a name="l00083"></a>00083     <span class="keywordtype">void</span> increment() { node_m = node_m-&gt;next(); }           
<a name="l00084"></a>00084     <span class="keywordtype">void</span> decrement() { node_m = node_m-&gt;prior(); }
<a name="l00085"></a>00085 
<a name="l00086"></a>00086     <span class="keyword">template</span>&lt; <span class="keyword">typename</span> O&gt;
<a name="l00087"></a>00087     <span class="keywordtype">bool</span> <a class="code" href="group__equal.html#gb42837481bc7251e15e3b67dd91f239c">equal</a>(<span class="keyword">const</span> closed_hash_iterator&lt;T, O&gt;&amp; y)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> node_m == y.node_m; }
<a name="l00088"></a>00088     
<a name="l00089"></a>00089     std::size_t state()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> node_m-&gt;state(); }
<a name="l00090"></a>00090     <span class="keywordtype">void</span> set_state(std::size_t x) { <span class="keywordflow">return</span> node_m-&gt;set_state(x); }
<a name="l00091"></a>00091 
<a name="l00092"></a>00092     <span class="keyword">explicit</span> closed_hash_iterator(node_t* node) : node_m(node) { }
<a name="l00093"></a>00093     
<a name="l00094"></a>00094     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="group__abi__container.html#g123a2e265d9c35109e121cb70b865f18">version_1::closed_hash_set</a>&lt;value_type, typename T::key_transform, typename T::hasher,
<a name="l00095"></a>00095             typename T::key_equal, typename T::allocator_type&gt;;
<a name="l00096"></a>00096     friend class boost::iterator_core_access;
<a name="l00097"></a>00097     friend struct unsafe::set_next_fn&lt;closed_hash_iterator&gt;;
<a name="l00098"></a>00098 };
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="comment">/*************************************************************************************************/</span>
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 } <span class="comment">// namespace implementation</span>
<a name="l00103"></a>00103 
<a name="l00104"></a>00104 <span class="comment">/*************************************************************************************************/</span>
<a name="l00105"></a>00105 
<a name="l00106"></a><a class="code" href="namespaceadobe_1_1unsafe.html">00106</a> namespace unsafe {
<a name="l00107"></a>00107 
<a name="l00108"></a>00108 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> V&gt;
<a name="l00109"></a>00109 <span class="keyword">struct </span>set_next_fn&lt;implementation::closed_hash_iterator&lt;T, V&gt; &gt;
<a name="l00110"></a>00110 {
<a name="l00111"></a>00111     <span class="keyword">typedef</span> <span class="keyword">typename</span> implementation::closed_hash_iterator&lt;T, V&gt; iterator;
<a name="l00112"></a>00112 
<a name="l00113"></a>00113     <span class="keywordtype">void</span> operator()(iterator x, iterator y)<span class="keyword"> const</span>
<a name="l00114"></a>00114 <span class="keyword">    </span>{ <a class="code" href="group__adobe__iterator.html#g5f4d1f99bf3aae004dd736f8a3fdb999">set_next</a>(*x.node_m, *y.node_m); }
<a name="l00115"></a>00115 };
<a name="l00116"></a>00116 
<a name="l00117"></a>00117 } <span class="comment">// namespace unsafe</span>
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 <span class="comment">/*************************************************************************************************/</span>
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 <span class="preprocessor">#ifndef ADOBE_NO_DOCUMENTATION</span>
<a name="l00122"></a>00122 <span class="preprocessor"></span>
<a name="l00123"></a>00123 <span class="keyword">namespace </span>version_1 {
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="preprocessor">#endif</span>
<a name="l00126"></a>00126 <span class="preprocessor"></span>
<a name="l00127"></a>00127 <span class="comment">/*************************************************************************************************/</span>
<a name="l00128"></a>00128 
<a name="l00152"></a>00152 <span class="keyword">template</span>&lt;   <span class="keyword">typename</span> T,
<a name="l00153"></a>00153             <span class="keyword">typename</span> KeyTransform,
<a name="l00154"></a>00154             <span class="keyword">typename</span> Hash,
<a name="l00155"></a>00155             <span class="keyword">typename</span> Pred,
<a name="l00156"></a>00156             <span class="keyword">typename</span> A&gt;
<a name="l00157"></a><a class="code" href="classadobe_1_1closed__hash__set.html">00157</a> <span class="keyword">class </span><a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a> : boost::<a class="code" href="classboost_1_1equality__comparable.html">equality_comparable</a>&lt;closed_hash_set&lt;T, KeyTransform, Hash, Pred, A&gt;,
<a name="l00158"></a>00158                                         closed_hash_set&lt;T, KeyTransform, Hash, Pred, A&gt;,
<a name="l00159"></a>00159                                         empty_base&lt;closed_hash_set&lt;T, KeyTransform, Hash, Pred, A&gt; &gt; &gt;
<a name="l00160"></a>00160 {
<a name="l00161"></a>00161  <span class="keyword">public</span>:
<a name="l00162"></a><a class="code" href="classadobe_1_1closed__hash__set.html#39dd655c38bd13b1b62a7b5254e91364">00162</a>     <span class="keyword">typedef</span> KeyTransform                        <a class="code" href="structadobe_1_1get__element.html">key_transform</a>;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164     <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::remove_reference&lt;typename key_transform::result_type&gt;::type
<a name="l00165"></a><a class="code" href="classadobe_1_1closed__hash__set.html#ea62ca54d915711e5c594c11e8c65f11">00165</a>                                                 <a class="code" href="namespaceadobe.html#0b1e8c11782fffe95a8e4a50790be36e">key_type</a>;
<a name="l00166"></a>00166 
<a name="l00167"></a><a class="code" href="classadobe_1_1closed__hash__set.html#265a253612b46abed17c61b0a5e5ce30">00167</a>     <span class="keyword">typedef</span> T                                   <a class="code" href="structadobe_1_1pair.html">value_type</a>;
<a name="l00168"></a><a class="code" href="classadobe_1_1closed__hash__set.html#f7b8e1e82680d9ca2c069a5a7ee77f28">00168</a>     <span class="keyword">typedef</span> Hash                                hasher;
<a name="l00169"></a><a class="code" href="classadobe_1_1closed__hash__set.html#c20c7adf363889ffc8c78183f3e9e942">00169</a>     <span class="keyword">typedef</span> Pred                                key_equal;
<a name="l00170"></a><a class="code" href="classadobe_1_1closed__hash__set.html#8876e3aa4a94471d5f91b914f0d37759">00170</a>     <span class="keyword">typedef</span> A                                   allocator_type;
<a name="l00171"></a><a class="code" href="classadobe_1_1closed__hash__set.html#d25b518036b886d8f35a3c059301d007">00171</a>     <span class="keyword">typedef</span> <a class="code" href="structadobe_1_1pair.html">value_type</a>*                         <a class="code" href="structadobe_1_1pair.html">pointer</a>;
<a name="l00172"></a><a class="code" href="classadobe_1_1closed__hash__set.html#13c57dab17e2c903cadfa5e35ba84064">00172</a>     <span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="structadobe_1_1pair.html">value_type</a>*                   <a class="code" href="structadobe_1_1pair.html">const_pointer</a>;
<a name="l00173"></a><a class="code" href="classadobe_1_1closed__hash__set.html#be8933d436779a43cb5c1896ff5f2918">00173</a>     <span class="keyword">typedef</span> <a class="code" href="structadobe_1_1pair.html">value_type</a>&amp;                         <a class="code" href="structadobe_1_1pair.html">reference</a>;
<a name="l00174"></a><a class="code" href="classadobe_1_1closed__hash__set.html#fdb67657e63a66ed3fae7b0c9fd81b48">00174</a>     <span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="structadobe_1_1pair.html">value_type</a>&amp;                   <a class="code" href="structadobe_1_1pair.html">const_reference</a>;
<a name="l00175"></a><a class="code" href="classadobe_1_1closed__hash__set.html#89a6dcafb6130e3e1bcd6d1285e0dd6f">00175</a>     <span class="keyword">typedef</span> std::size_t                         size_type;
<a name="l00176"></a><a class="code" href="classadobe_1_1closed__hash__set.html#d319fc54a93a2c7058c70e40428ed2e2">00176</a>     <span class="keyword">typedef</span> std::ptrdiff_t                      difference_type;
<a name="l00177"></a>00177 
<a name="l00178"></a>00178     <span class="keyword">friend</span> <span class="keyword">class </span>implementation::closed_hash_iterator&lt;<a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>, <a class="code" href="structadobe_1_1pair.html">value_type</a>&gt;;
<a name="l00179"></a>00179     <span class="keyword">friend</span> <span class="keyword">class </span>implementation::closed_hash_iterator&lt;<a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>, const <a class="code" href="structadobe_1_1pair.html">value_type</a>&gt;;
<a name="l00180"></a>00180     
<a name="l00181"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">00181</a>     <span class="keyword">typedef</span> implementation::closed_hash_iterator&lt;closed_hash_set, value_type&gt;       <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a>;
<a name="l00182"></a><a class="code" href="classadobe_1_1closed__hash__set.html#96af92cff83ecc57d226f5e3df7f173b">00182</a>     <span class="keyword">typedef</span> implementation::closed_hash_iterator&lt;closed_hash_set, const value_type&gt; <a class="code" href="classadobe_1_1closed__hash__set.html#96af92cff83ecc57d226f5e3df7f173b">const_iterator</a>;
<a name="l00183"></a>00183 
<a name="l00184"></a><a class="code" href="classadobe_1_1closed__hash__set.html#92b881db836646f4039adcbb73c8595f">00184</a>     <span class="keyword">typedef</span> std::reverse_iterator&lt;iterator&gt;         reverse_iterator;
<a name="l00185"></a><a class="code" href="classadobe_1_1closed__hash__set.html#421ef78ccdc84f0f6b2b14e2732527ba">00185</a>     <span class="keyword">typedef</span> std::reverse_iterator&lt;const_iterator&gt;   const_reverse_iterator;
<a name="l00186"></a>00186 
<a name="l00187"></a>00187  <span class="keyword">private</span>:
<a name="l00188"></a>00188     <span class="keyword">enum</span>
<a name="l00189"></a>00189     {
<a name="l00190"></a>00190         state_free          = 0,
<a name="l00191"></a>00191         state_home          = 1,
<a name="l00192"></a>00192         state_misplaced     = 2
<a name="l00193"></a>00193     };
<a name="l00194"></a>00194     
<a name="l00195"></a>00195     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="comment">// U is derived node</span>
<a name="l00196"></a>00196     <span class="keyword">struct </span>list_node_base
<a name="l00197"></a>00197     {
<a name="l00198"></a>00198         list_node_base() { next_m = <span class="keyword">static_cast&lt;</span>U*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); prior_m = <span class="keyword">static_cast&lt;</span>U*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00199"></a>00199         
<a name="l00200"></a>00200         U* address() { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>U*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00201"></a>00201         <span class="keyword">const</span> U* address()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>U*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00202"></a>00202         
<a name="l00203"></a>00203         operator U&amp; () { <span class="keywordflow">return</span> *<span class="keyword">static_cast&lt;</span>U*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00204"></a>00204         operator const U&amp; ()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *<span class="keyword">static_cast&lt;</span><span class="keyword">const </span>U*<span class="keyword">&gt;</span>(<span class="keyword">this</span>); }
<a name="l00205"></a>00205         
<a name="l00206"></a>00206         <span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__adobe__iterator.html#g5f4d1f99bf3aae004dd736f8a3fdb999">set_next</a>(U&amp; x, U&amp; y)
<a name="l00207"></a>00207         { x.next_m = <span class="keyword">reinterpret_cast&lt;</span>U*<span class="keyword">&gt;</span>(<a class="code" href="group__tr1.html#g83242de74310b4aec3fc506bc3644211">uintptr_t</a>(&amp;y) | <a class="code" href="group__tr1.html#g83242de74310b4aec3fc506bc3644211">uintptr_t</a>(x.state())); y.prior_m = &amp;x; }
<a name="l00208"></a>00208             
<a name="l00209"></a>00209         <span class="keyword">friend</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> set_next_raw(U&amp; x, U&amp; y)
<a name="l00210"></a>00210         { x.next_m = &amp;y; y.prior_m = &amp;x; }
<a name="l00211"></a>00211         
<a name="l00212"></a>00212         std::size_t state()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> std::size_t(<a class="code" href="group__tr1.html#g83242de74310b4aec3fc506bc3644211">uintptr_t</a>(next_m) &amp; <a class="code" href="group__tr1.html#g83242de74310b4aec3fc506bc3644211">uintptr_t</a>(0x03UL)); }
<a name="l00213"></a>00213         <span class="keywordtype">void</span> set_state(std::size_t x)
<a name="l00214"></a>00214         {
<a name="l00215"></a>00215             assert(x &lt; 0x04UL);
<a name="l00216"></a>00216             next_m = <span class="keyword">reinterpret_cast&lt;</span>U*<span class="keyword">&gt;</span>(<a class="code" href="group__tr1.html#g83242de74310b4aec3fc506bc3644211">uintptr_t</a>(next()) | <a class="code" href="group__tr1.html#g83242de74310b4aec3fc506bc3644211">uintptr_t</a>(x));
<a name="l00217"></a>00217         }
<a name="l00218"></a>00218         
<a name="l00219"></a>00219         U* next()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">reinterpret_cast&lt;</span>U*<span class="keyword">&gt;</span>(<span class="keyword">reinterpret_cast&lt;</span><a class="code" href="group__tr1.html#g83242de74310b4aec3fc506bc3644211">uintptr_t</a><span class="keyword">&gt;</span>(next_m) &amp; ~<a class="code" href="group__tr1.html#g83242de74310b4aec3fc506bc3644211">uintptr_t</a>(0x03UL)); }
<a name="l00220"></a>00220         U* prior()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> prior_m; }
<a name="l00221"></a>00221 
<a name="l00222"></a>00222      <span class="keyword">private</span>:
<a name="l00223"></a>00223         U* next_m;
<a name="l00224"></a>00224         U* prior_m;
<a name="l00225"></a>00225     };
<a name="l00226"></a>00226     
<a name="l00227"></a>00227     <span class="keyword">struct </span>node_t : list_node_base&lt;node_t&gt;
<a name="l00228"></a>00228     {
<a name="l00229"></a>00229         T           value_m;
<a name="l00230"></a>00230     };
<a name="l00231"></a>00231     
<a name="l00232"></a>00232     <span class="keyword">typedef</span> list_node_base&lt;node_t&gt; node_base_t;
<a name="l00233"></a>00233     
<a name="l00234"></a>00234     <span class="keyword">struct </span>header_t
<a name="l00235"></a>00235     {
<a name="l00236"></a><a class="code" href="structadobe_1_1closed__hash__set_1_1header__t_1_1compact__header__t.html">00236</a>         <span class="keyword">struct </span><a class="code" href="structadobe_1_1closed__hash__set_1_1header__t_1_1compact__header__t.html">compact_header_t</a>
<a name="l00237"></a>00237         {
<a name="l00238"></a><a class="code" href="structadobe_1_1closed__hash__set_1_1header__t_1_1compact__header__t.html#57a28b2c46effffc0c48045a43f0b6fc">00238</a>             boost::compressed_pair&lt;allocator_type, node_base_t&gt; alloc_free_tail_m;
<a name="l00239"></a><a class="code" href="structadobe_1_1closed__hash__set_1_1header__t_1_1compact__header__t.html#837dc8a3af3eb4f51d20cbff7f03a168">00239</a>             node_base_t used_tail_m;
<a name="l00240"></a><a class="code" href="structadobe_1_1closed__hash__set_1_1header__t_1_1compact__header__t.html#72533e0491ebe6ad4e0439a0cd41d107">00240</a>             std::size_t capacity_m;
<a name="l00241"></a><a class="code" href="structadobe_1_1closed__hash__set_1_1header__t_1_1compact__header__t.html#be627e64ae3a6c5a067a940605d559f9">00241</a>             std::size_t size_m;
<a name="l00242"></a>00242         };
<a name="l00243"></a>00243         
<a name="l00244"></a>00244         <span class="comment">/*</span>
<a name="l00245"></a>00245 <span class="comment">        NOTE (sparent) - the assumption is that the initial items are pointers and that size_t is</span>
<a name="l00246"></a>00246 <span class="comment">        either equal to the sizeof a pointer or a lower power of two so this packs tightly.</span>
<a name="l00247"></a>00247 <span class="comment">        */</span>
<a name="l00248"></a>00248         
<a name="l00249"></a>00249         <a class="code" href="namespaceadobe.html#0d19002ca08b6fc1baf4fad3522925c3">BOOST_STATIC_ASSERT</a>(!(<span class="keyword">sizeof</span>(A) == <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*) || <span class="keyword">sizeof</span>(A) == 0)
<a name="l00250"></a>00250             || (<span class="keyword">sizeof</span>(<a class="code" href="structadobe_1_1closed__hash__set_1_1header__t_1_1compact__header__t.html">compact_header_t</a>) == (<span class="keyword">sizeof</span>(allocator_type) + 2 * <span class="keyword">sizeof</span>(node_base_t) + 2 *
<a name="l00251"></a>00251                 <span class="keyword">sizeof</span>(std::size_t))));
<a name="l00252"></a>00252         
<a name="l00253"></a>00253         <a class="code" href="structadobe_1_1aligned__storage.html">aligned_storage&lt;compact_header_t&gt;</a> header_m;
<a name="l00254"></a>00254         node_t      storage_m[1];
<a name="l00255"></a>00255         
<a name="l00256"></a>00256         allocator_type&amp;  allocator() { <span class="keywordflow">return</span> header_m.get().alloc_free_tail_m.first(); }
<a name="l00257"></a>00257         <span class="keyword">const</span> allocator_type&amp; allocator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> header_m.get().alloc_free_tail_m.first(); }
<a name="l00258"></a>00258         node_base_t&amp;  free_tail() { <span class="keywordflow">return</span> header_m.get().alloc_free_tail_m.second(); }
<a name="l00259"></a>00259         <span class="keyword">const</span> node_base_t&amp; free_tail()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> header_m.get().alloc_free_tail_m.second(); }
<a name="l00260"></a>00260         node_base_t&amp;  used_tail() { <span class="keywordflow">return</span> header_m.get().used_tail_m; }
<a name="l00261"></a>00261         <span class="keyword">const</span> node_base_t&amp; used_tail()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> header_m.get().used_tail_m; }
<a name="l00262"></a>00262         std::size_t&amp;  capacity() { <span class="keywordflow">return</span> header_m.get().capacity_m; }
<a name="l00263"></a>00263         <span class="keyword">const</span> std::size_t&amp; capacity()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> header_m.get().capacity_m; }
<a name="l00264"></a>00264         std::size_t&amp;  <a class="code" href="group__selection__algorithms.html#g7c5bdb55e42beda2cd6acbe643ef4fa2">size</a>() { <span class="keywordflow">return</span> header_m.get().size_m; }
<a name="l00265"></a>00265         <span class="keyword">const</span> std::size_t&amp; <a class="code" href="group__selection__algorithms.html#g7c5bdb55e42beda2cd6acbe643ef4fa2">size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> header_m.get().size_m; }
<a name="l00266"></a>00266     };
<a name="l00267"></a>00267     
<a name="l00268"></a>00268     <span class="keyword">typedef</span> node_t* node_ptr;
<a name="l00269"></a>00269 
<a name="l00270"></a>00270     <span class="keyword">typedef</span> boost::compressed_pair&lt; hasher,
<a name="l00271"></a>00271                                     boost::compressed_pair&lt; key_equal,
<a name="l00272"></a>00272                                                             boost::compressed_pair&lt; key_transform,
<a name="l00273"></a>00273                                                                                     header_t*
<a name="l00274"></a>00274                                                                                   &gt;
<a name="l00275"></a>00275                                                           &gt;
<a name="l00276"></a>00276                                   &gt; data_t;
<a name="l00277"></a>00277 
<a name="l00278"></a>00278     data_t  data_m;
<a name="l00279"></a>00279 
<a name="l00280"></a>00280     <span class="keyword">typedef</span> header_t* header_pointer;
<a name="l00281"></a>00281    
<a name="l00282"></a>00282     <span class="keyword">const</span> header_pointer&amp; header()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> data_m.second().second().second(); }
<a name="l00283"></a>00283     header_pointer&amp; header() { <span class="keywordflow">return</span> data_m.second().second().second(); }
<a name="l00284"></a>00284     
<a name="l00285"></a>00285  <span class="keyword">public</span>:
<a name="l00286"></a>00286     <span class="comment">// construct/destroy/copy</span>
<a name="l00287"></a>00287 
<a name="l00288"></a><a class="code" href="classadobe_1_1closed__hash__set.html#3d568316e3b40becf25203ae2bac5643">00288</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#3d568316e3b40becf25203ae2bac5643">closed_hash_set</a>() { header() = 0; }
<a name="l00289"></a>00289     
<a name="l00290"></a><a class="code" href="classadobe_1_1closed__hash__set.html#e9ab2c4ac6b91555f1b6a32c76b079a3">00290</a>     <span class="keyword">explicit</span> <a class="code" href="group__abi__container.html#g123a2e265d9c35109e121cb70b865f18">closed_hash_set</a>(size_type n)
<a name="l00291"></a>00291     {
<a name="l00292"></a>00292         header() = 0;
<a name="l00293"></a>00293         allocate(allocator_type(), n);
<a name="l00294"></a>00294     }
<a name="l00295"></a>00295     
<a name="l00296"></a><a class="code" href="classadobe_1_1closed__hash__set.html#34f0a7991a6b5c4e7111bd13b7be2fa5">00296</a>     <a class="code" href="group__abi__container.html#g123a2e265d9c35109e121cb70b865f18">closed_hash_set</a>(size_type n, <span class="keyword">const</span> hasher&amp; hf, <span class="keyword">const</span> key_equal&amp; eq = key_equal(),
<a name="l00297"></a>00297                                                    <span class="keyword">const</span> <a class="code" href="structadobe_1_1get__element.html">key_transform</a>&amp; kf = <a class="code" href="structadobe_1_1get__element.html">key_transform</a>(),
<a name="l00298"></a>00298                                                    <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00299"></a>00299     {
<a name="l00300"></a>00300         header() = 0;
<a name="l00301"></a>00301         data_m.first() = hf;
<a name="l00302"></a>00302         data_m.second().first() = eq;
<a name="l00303"></a>00303         data_m.second().second().first() = kf;
<a name="l00304"></a>00304         allocate(a, n);
<a name="l00305"></a>00305     }
<a name="l00306"></a>00306 
<a name="l00307"></a>00307     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt; <span class="comment">// I models InputIterator</span>
<a name="l00308"></a><a class="code" href="classadobe_1_1closed__hash__set.html#0d1010cb73d6e1e023d2f7a4777656c0">00308</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#0d1010cb73d6e1e023d2f7a4777656c0">closed_hash_set</a>(I f, I l) { header() = 0; <a class="code" href="group__sequence__model__concept.html#gea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(f, l); }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt; <span class="comment">// I models InputIterator</span>
<a name="l00311"></a><a class="code" href="classadobe_1_1closed__hash__set.html#16ddcde29b395ae25385311120330487">00311</a>     <a class="code" href="group__abi__container.html#g123a2e265d9c35109e121cb70b865f18">closed_hash_set</a>(I f, I l, size_type n, <span class="keyword">const</span> hasher&amp; hf = hasher(),
<a name="l00312"></a>00312                                            <span class="keyword">const</span> key_equal&amp; eq = key_equal(),
<a name="l00313"></a>00313                                            <span class="keyword">const</span> <a class="code" href="structadobe_1_1get__element.html">key_transform</a>&amp; kf = <a class="code" href="structadobe_1_1get__element.html">key_transform</a>(),
<a name="l00314"></a>00314                                            <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00315"></a>00315     {
<a name="l00316"></a>00316         header() = 0;
<a name="l00317"></a>00317         data_m.first() = hf;
<a name="l00318"></a>00318         data_m.second().first() = eq;
<a name="l00319"></a>00319         data_m.second().second().first() = kf;
<a name="l00320"></a>00320         allocate(a, n);
<a name="l00321"></a>00321         <a class="code" href="group__sequence__model__concept.html#gea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(f, l);
<a name="l00322"></a>00322     }
<a name="l00323"></a>00323     
<a name="l00324"></a><a class="code" href="classadobe_1_1closed__hash__set.html#cc9d1faa43faf0a10893e030f18e60fb">00324</a>     <a class="code" href="group__abi__container.html#g123a2e265d9c35109e121cb70b865f18">closed_hash_set</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>&amp; x) : data_m(x.data_m)
<a name="l00325"></a>00325     {
<a name="l00326"></a>00326         header() = 0;
<a name="l00327"></a>00327         allocate(x.<a class="code" href="classadobe_1_1closed__hash__set.html#cfbc5374e81f060b1cdffeb9c494ae86">get_allocator</a>(), x.<a class="code" href="classadobe_1_1closed__hash__set.html#503ab01f6c0142145d3434f6924714e7">size</a>());
<a name="l00328"></a>00328         <a class="code" href="group__sequence__model__concept.html#gea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(x.<a class="code" href="classadobe_1_1closed__hash__set.html#d69bd11391be1a1dba5c8202259664f8">begin</a>(), x.<a class="code" href="classadobe_1_1closed__hash__set.html#cad38d52497a975bfb6f2f6acd76631f">end</a>());
<a name="l00329"></a>00329     }
<a name="l00330"></a><a class="code" href="classadobe_1_1closed__hash__set.html#92d00a7bf493893de05a2ee93853a3e6">00330</a>     <a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>&amp; <a class="code" href="classadobe_1_1closed__hash__set.html#92d00a7bf493893de05a2ee93853a3e6">operator=</a>(<a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a> x) { <a class="code" href="namespaceadobe.html#5c6656b2ba51d81c71a97670f3b15a83">swap</a>(x, *<span class="keyword">this</span>); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00331"></a>00331 
<a name="l00332"></a><a class="code" href="classadobe_1_1closed__hash__set.html#cfbc5374e81f060b1cdffeb9c494ae86">00332</a>     allocator_type get_allocator()<span class="keyword"> const</span>
<a name="l00333"></a>00333 <span class="keyword">    </span>{ <span class="keywordflow">return</span> header() ? header()-&gt;allocator() : allocator_type(); }
<a name="l00334"></a>00334 
<a name="l00335"></a><a class="code" href="classadobe_1_1closed__hash__set.html#5ee6296d5a13e4837d677d74caad38c1">00335</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#5ee6296d5a13e4837d677d74caad38c1">closed_hash_set</a>(<a class="code" href="structadobe_1_1move__from.html" title="move_from is used for move_ctors.">move_from&lt;closed_hash_set&gt;</a> x) : data_m(x.source.data_m) { x.<a class="code" href="structadobe_1_1move__from.html#3fc86dd652c668de2fecaa29375d0d2b">source</a>.header() = 0; }
<a name="l00336"></a>00336 
<a name="l00337"></a>00337 <span class="preprocessor">#if 0</span>
<a name="l00338"></a>00338 <span class="preprocessor"></span>    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt; <span class="comment">// I models ForwardIterator</span>
<a name="l00339"></a>00339     <a class="code" href="group__abi__container.html#g123a2e265d9c35109e121cb70b865f18">closed_hash_set</a>(I f, I l, move_ctor) { header() = 0; move_insert(f, l); }
<a name="l00340"></a>00340 <span class="preprocessor">#endif</span>
<a name="l00341"></a>00341 <span class="preprocessor"></span>
<a name="l00342"></a>00342     <span class="comment">// size and capacity</span>
<a name="l00343"></a>00343 
<a name="l00344"></a><a class="code" href="classadobe_1_1closed__hash__set.html#503ab01f6c0142145d3434f6924714e7">00344</a>     size_type <a class="code" href="classadobe_1_1closed__hash__set.html#503ab01f6c0142145d3434f6924714e7">size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> header() ? header()-&gt;size() : 0; }
<a name="l00345"></a><a class="code" href="classadobe_1_1closed__hash__set.html#0ab5ce862c0331d9e45a6e1774fca131">00345</a>     size_type <a class="code" href="classadobe_1_1closed__hash__set.html#0ab5ce862c0331d9e45a6e1774fca131">max_size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> size_type(-1) / <span class="keyword">sizeof</span>(node_t); }
<a name="l00346"></a><a class="code" href="classadobe_1_1closed__hash__set.html#c6e61de369e994009e36f344f99c15ad">00346</a>     <span class="keywordtype">bool</span> <a class="code" href="classadobe_1_1closed__hash__set.html#c6e61de369e994009e36f344f99c15ad">empty</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="group__selection__algorithms.html#g7c5bdb55e42beda2cd6acbe643ef4fa2">size</a>() == 0; }
<a name="l00347"></a><a class="code" href="classadobe_1_1closed__hash__set.html#b009512ed674371bda87b4a4a3fc7305">00347</a>     size_type <a class="code" href="classadobe_1_1closed__hash__set.html#b009512ed674371bda87b4a4a3fc7305">capacity</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> header() ? header()-&gt;capacity() : 0; }
<a name="l00348"></a>00348 
<a name="l00349"></a><a class="code" href="classadobe_1_1closed__hash__set.html#562f7b24b47d3e7632a9896935c14d8b">00349</a>     <span class="keywordtype">void</span> reserve(size_type n)
<a name="l00350"></a>00350     {
<a name="l00351"></a>00351         <span class="keywordflow">if</span> (n &lt;= capacity()) <span class="keywordflow">return</span>;
<a name="l00352"></a>00352         
<a name="l00353"></a>00353         <span class="keywordflow">if</span> (!header()) allocate(allocator_type(), n);
<a name="l00354"></a>00354         <span class="keywordflow">else</span>
<a name="l00355"></a>00355         {
<a name="l00356"></a>00356             <a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a> tmp(n, hash_function(), key_eq(), key_function(), get_allocator());
<a name="l00357"></a>00357             tmp.<a class="code" href="classadobe_1_1closed__hash__set.html#3ca9357c49ea5883e29501dee02ea5d7">move_insert</a>(begin(), end());
<a name="l00358"></a>00358             <a class="code" href="namespaceadobe.html#5c6656b2ba51d81c71a97670f3b15a83">swap</a>(*<span class="keyword">this</span>, tmp);
<a name="l00359"></a>00359         }
<a name="l00360"></a>00360     }
<a name="l00361"></a>00361     
<a name="l00362"></a><a class="code" href="classadobe_1_1closed__hash__set.html#67dbb7e2ef73eef7948ffcea921d6d56">00362</a>     <a class="code" href="structadobe_1_1get__element.html">key_transform</a> <a class="code" href="classadobe_1_1closed__hash__set.html#67dbb7e2ef73eef7948ffcea921d6d56">key_function</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> data_m.second().second().first(); }
<a name="l00363"></a><a class="code" href="classadobe_1_1closed__hash__set.html#1bfb95fcf670a1793ee7ecb7475493a3">00363</a>     hasher <a class="code" href="classadobe_1_1closed__hash__set.html#1bfb95fcf670a1793ee7ecb7475493a3">hash_function</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> data_m.first(); }
<a name="l00364"></a><a class="code" href="classadobe_1_1closed__hash__set.html#082eb35d8ade72f084455c3decee613f">00364</a>     key_equal <a class="code" href="classadobe_1_1closed__hash__set.html#082eb35d8ade72f084455c3decee613f">key_eq</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> data_m.second().first(); }
<a name="l00365"></a>00365     
<a name="l00366"></a><a class="code" href="classadobe_1_1closed__hash__set.html#d69bd11391be1a1dba5c8202259664f8">00366</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> <a class="code" href="classadobe_1_1closed__hash__set.html#d69bd11391be1a1dba5c8202259664f8">begin</a>() { <span class="keywordflow">return</span> <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a>(header() ? header()-&gt;used_tail().next() : 0); }
<a name="l00367"></a><a class="code" href="classadobe_1_1closed__hash__set.html#cad38d52497a975bfb6f2f6acd76631f">00367</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> <a class="code" href="classadobe_1_1closed__hash__set.html#cad38d52497a975bfb6f2f6acd76631f">end</a>() { <span class="keywordflow">return</span> <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a>(header() ? header()-&gt;used_tail().address() : 0); }
<a name="l00368"></a>00368     
<a name="l00369"></a><a class="code" href="classadobe_1_1closed__hash__set.html#a4b02d4f1a8500fb07a551069060709f">00369</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#96af92cff83ecc57d226f5e3df7f173b">const_iterator</a> <a class="code" href="classadobe_1_1closed__hash__set.html#a4b02d4f1a8500fb07a551069060709f">begin</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a>(header() ? header()-&gt;used_tail().next() : 0); }
<a name="l00370"></a><a class="code" href="classadobe_1_1closed__hash__set.html#350132543d80a1c1e5be844e6d2878ea">00370</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#96af92cff83ecc57d226f5e3df7f173b">const_iterator</a> <a class="code" href="classadobe_1_1closed__hash__set.html#350132543d80a1c1e5be844e6d2878ea">end</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a>(header() ? const_cast&lt;node_t*&gt;(header()-&gt;used_tail().address()) : 0); }
<a name="l00371"></a>00371     
<a name="l00372"></a><a class="code" href="classadobe_1_1closed__hash__set.html#cea44ed500a54b2bb93e16b86e81afa8">00372</a>     reverse_iterator <a class="code" href="classadobe_1_1closed__hash__set.html#cea44ed500a54b2bb93e16b86e81afa8">rbegin</a>() { <span class="keywordflow">return</span> reverse_iterator(end()); }
<a name="l00373"></a><a class="code" href="classadobe_1_1closed__hash__set.html#68c599ddcbfddc65170de524ac165e44">00373</a>     reverse_iterator <a class="code" href="classadobe_1_1closed__hash__set.html#68c599ddcbfddc65170de524ac165e44">rend</a>() { <span class="keywordflow">return</span> reverse_iterator(begin()); }
<a name="l00374"></a>00374     
<a name="l00375"></a><a class="code" href="classadobe_1_1closed__hash__set.html#04886aa70c34d66738e78bf70c675e66">00375</a>     const_reverse_iterator <a class="code" href="classadobe_1_1closed__hash__set.html#04886aa70c34d66738e78bf70c675e66">rbegin</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> const_reverse_iterator(end()); }
<a name="l00376"></a><a class="code" href="classadobe_1_1closed__hash__set.html#b3c414470d5cea2986cfab7a90146cb6">00376</a>     const_reverse_iterator <a class="code" href="classadobe_1_1closed__hash__set.html#b3c414470d5cea2986cfab7a90146cb6">rend</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> const_reverse_iterator(begin()); }
<a name="l00377"></a>00377     
<a name="l00378"></a><a class="code" href="classadobe_1_1closed__hash__set.html#09ec269da9e5936d292aaf134477eceb">00378</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> <a class="code" href="group__erase.html#gea27cdb7a5b7013f3ca4e2102b28a096">erase</a>(<a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> location)
<a name="l00379"></a>00379     {
<a name="l00380"></a>00380         <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> next(boost::next(location));
<a name="l00381"></a>00381         <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> result = next;
<a name="l00382"></a>00382     
<a name="l00383"></a>00383         <span class="keywordflow">if</span> ((location.state() == std::size_t(state_home)) &amp;&amp; (next != end())
<a name="l00384"></a>00384                 &amp;&amp; (next.state() == std::size_t(state_misplaced)))
<a name="l00385"></a>00385         {
<a name="l00386"></a>00386             <a class="code" href="namespaceadobe.html#5c6656b2ba51d81c71a97670f3b15a83">swap</a>(*next, *location);
<a name="l00387"></a>00387             result = location;
<a name="l00388"></a>00388             location = next;
<a name="l00389"></a>00389         }
<a name="l00390"></a>00390     
<a name="l00391"></a>00391         <a class="code" href="group__adobe__iterator.html#g3adeba343a28c39563dc4aae37f22421">unsafe::skip_node</a>(location);
<a name="l00392"></a>00392         erase_raw(location);
<a name="l00393"></a>00393         
<a name="l00394"></a>00394         --header()-&gt;size();
<a name="l00395"></a>00395         
<a name="l00396"></a>00396         <span class="keywordflow">return</span> result;
<a name="l00397"></a>00397     }
<a name="l00398"></a>00398     
<a name="l00399"></a><a class="code" href="classadobe_1_1closed__hash__set.html#54aa36e2195f7b699df332329c7c0e66">00399</a>     std::size_t <a class="code" href="group__erase.html#gea27cdb7a5b7013f3ca4e2102b28a096">erase</a>(<span class="keyword">const</span> <a class="code" href="namespaceadobe.html#0b1e8c11782fffe95a8e4a50790be36e">key_type</a>&amp; key)
<a name="l00400"></a>00400     {
<a name="l00401"></a>00401         <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> node(<a class="code" href="group__find.html#g3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(key));
<a name="l00402"></a>00402         <span class="keywordflow">if</span> (node == end()) <span class="keywordflow">return</span> 0;
<a name="l00403"></a>00403         <a class="code" href="group__erase.html#gea27cdb7a5b7013f3ca4e2102b28a096">erase</a>(node);
<a name="l00404"></a>00404         <span class="keywordflow">return</span> 1;
<a name="l00405"></a>00405     }
<a name="l00406"></a>00406     
<a name="l00407"></a><a class="code" href="classadobe_1_1closed__hash__set.html#c8bb3912a3ce86b15842e79d0b421204">00407</a>     <span class="keywordtype">void</span> <a class="code" href="group__sequence__view.html#ge86d3d95373ce0d9f1d92c9f62b58d14" title="SequenceView concept requirement.">clear</a>()
<a name="l00408"></a>00408     {
<a name="l00409"></a>00409         <span class="keywordflow">for</span>(<a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> first(begin()), last(end()); first != last; first = <a class="code" href="group__erase.html#gea27cdb7a5b7013f3ca4e2102b28a096">erase</a>(first)) ;
<a name="l00410"></a>00410     }
<a name="l00411"></a>00411     
<a name="l00412"></a><a class="code" href="classadobe_1_1closed__hash__set.html#dc204502ef1606c9daa4a613da6aacfb">00412</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#96af92cff83ecc57d226f5e3df7f173b">const_iterator</a> <a class="code" href="group__find.html#g3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(<span class="keyword">const</span> <a class="code" href="namespaceadobe.html#0b1e8c11782fffe95a8e4a50790be36e">key_type</a>&amp; key)<span class="keyword"> const</span>
<a name="l00413"></a>00413 <span class="keyword">    </span>{
<a name="l00414"></a>00414         <span class="keywordflow">return</span> <a class="code" href="group__conversion.html#g491e23f2732f7ee1f63acd34a515cba3">adobe::remove_const</a>(*this).find(key);
<a name="l00415"></a>00415     }
<a name="l00416"></a>00416     
<a name="l00417"></a><a class="code" href="classadobe_1_1closed__hash__set.html#9c9766a96c492f3e9e5861d6b4f87387">00417</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> <a class="code" href="group__find.html#g3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(<span class="keyword">const</span> <a class="code" href="namespaceadobe.html#0b1e8c11782fffe95a8e4a50790be36e">key_type</a>&amp; key)
<a name="l00418"></a>00418     {
<a name="l00419"></a>00419         <span class="keywordflow">if</span> (empty()) <span class="keywordflow">return</span> end();
<a name="l00420"></a>00420         
<a name="l00421"></a>00421         <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> node(bucket(key));
<a name="l00422"></a>00422         
<a name="l00423"></a>00423         <span class="keywordflow">if</span> (node.state() != std::size_t(state_home)) <span class="keywordflow">return</span> end();
<a name="l00424"></a>00424         
<a name="l00425"></a>00425         <span class="keywordflow">return</span> <a class="code" href="group__find.html#g3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(node, key);
<a name="l00426"></a>00426     }
<a name="l00427"></a>00427     
<a name="l00428"></a><a class="code" href="classadobe_1_1closed__hash__set.html#33c1ee0eb39360edec2a985301b9d631">00428</a>     std::pair&lt;const_iterator, const_iterator&gt; <a class="code" href="group__equal__range.html#g2f886d190fe33fac6a38f6d79500f887">equal_range</a>(<span class="keyword">const</span> <a class="code" href="namespaceadobe.html#0b1e8c11782fffe95a8e4a50790be36e">key_type</a>&amp; key)<span class="keyword"> const</span>
<a name="l00429"></a>00429 <span class="keyword">    </span>{
<a name="l00430"></a>00430         <a class="code" href="classadobe_1_1closed__hash__set.html#96af92cff83ecc57d226f5e3df7f173b">const_iterator</a> result = <a class="code" href="group__find.html#g3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(key);
<a name="l00431"></a>00431         <span class="keywordflow">if</span> (result == end()) <span class="keywordflow">return</span> <a class="code" href="group__asl__pair.html#g86cec50e4c5771ecd54930cc50dedcfd">std::make_pair</a>(result, result);
<a name="l00432"></a>00432         <span class="keywordflow">return</span> <a class="code" href="group__asl__pair.html#g86cec50e4c5771ecd54930cc50dedcfd">std::make_pair</a>(result, boost::next(result));
<a name="l00433"></a>00433     }
<a name="l00434"></a>00434     
<a name="l00435"></a><a class="code" href="classadobe_1_1closed__hash__set.html#97bb054bc81e97ec55f0b539cdcbfcde">00435</a>     std::pair&lt;iterator, iterator&gt; <a class="code" href="group__equal__range.html#g2f886d190fe33fac6a38f6d79500f887">equal_range</a>(<span class="keyword">const</span> <a class="code" href="namespaceadobe.html#0b1e8c11782fffe95a8e4a50790be36e">key_type</a>&amp; key)
<a name="l00436"></a>00436     {
<a name="l00437"></a>00437         <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> result = <a class="code" href="group__find.html#g3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(key);
<a name="l00438"></a>00438         <span class="keywordflow">if</span> (result == end()) <span class="keywordflow">return</span> <a class="code" href="group__asl__pair.html#g86cec50e4c5771ecd54930cc50dedcfd">std::make_pair</a>(result, result);
<a name="l00439"></a>00439         <span class="keywordflow">return</span> <a class="code" href="group__asl__pair.html#g86cec50e4c5771ecd54930cc50dedcfd">std::make_pair</a>(result, boost::next(result));
<a name="l00440"></a>00440     }
<a name="l00441"></a>00441     
<a name="l00442"></a><a class="code" href="classadobe_1_1closed__hash__set.html#1f51634779163f098196e3ac00d1489b">00442</a>     std::size_t <a class="code" href="group__count.html#g0a7c479c6dffa60d3aae2abdcce31a5e" title="count implementation">count</a>(<span class="keyword">const</span> <a class="code" href="namespaceadobe.html#0b1e8c11782fffe95a8e4a50790be36e">key_type</a>&amp; key)<span class="keyword"> const</span>
<a name="l00443"></a>00443 <span class="keyword">    </span>{ <span class="keywordflow">return</span> std::size_t(<a class="code" href="group__find.html#g3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(key) != end()); }
<a name="l00444"></a>00444     
<a name="l00445"></a>00445     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt; <span class="comment">// I models InputIterator</span>
<a name="l00446"></a><a class="code" href="classadobe_1_1closed__hash__set.html#ef04f1899e941779d01d9d0c2e2825c0">00446</a>     <span class="keywordtype">void</span> <a class="code" href="group__sequence__model__concept.html#gea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(I first, I last)
<a name="l00447"></a>00447     { <span class="keywordflow">while</span> (first != last) { <a class="code" href="classadobe_1_1closed__hash__set.html#ef04f1899e941779d01d9d0c2e2825c0">insert</a>(*first); ++first; } }
<a name="l00448"></a>00448     
<a name="l00449"></a>00449     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt; <span class="comment">// I models ForwardIterator</span>
<a name="l00450"></a><a class="code" href="classadobe_1_1closed__hash__set.html#3ca9357c49ea5883e29501dee02ea5d7">00450</a>     <span class="keywordtype">void</span> move_insert(I first, I last)
<a name="l00451"></a>00451     { <span class="keywordflow">while</span> (first != last) { <a class="code" href="group__sequence__model__concept.html#gea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(<a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(*first)); ++first; } }
<a name="l00452"></a>00452     
<a name="l00453"></a>00453     <span class="comment">/*</span>
<a name="l00454"></a>00454 <span class="comment">        NOTE (sparent): If there is not enough space for one element we will reserve the space</span>
<a name="l00455"></a>00455 <span class="comment">        prior to attempting the insert even if the item is already in the hash table. Without</span>
<a name="l00456"></a>00456 <span class="comment">        recalculating the bucket (a potentially expensive operation) there is no other solution.</span>
<a name="l00457"></a>00457 <span class="comment">    */</span>
<a name="l00458"></a>00458     
<a name="l00459"></a>00459     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;
<a name="l00460"></a><a class="code" href="classadobe_1_1closed__hash__set.html#7ba5ffdbcc08843700d21cf7a910df11">00460</a>     std::pair&lt;iterator, bool&gt; <a class="code" href="group__sequence__model__concept.html#gea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(<span class="keyword">const</span> U&amp; x, <span class="keyword">typename</span> <a class="code" href="structadobe_1_1copy__sink.html" title="copy_sink and move_sink are used to select between overloaded operations according...">copy_sink&lt;U, value_type&gt;::type</a> = 0)
<a name="l00461"></a>00461     {
<a name="l00462"></a>00462         <span class="keywordflow">if</span> (capacity() == <a class="code" href="group__selection__algorithms.html#g7c5bdb55e42beda2cd6acbe643ef4fa2">size</a>()) {
<a name="l00463"></a>00463             <a class="code" href="structadobe_1_1pair.html">value_type</a> tmp(x); <span class="comment">// Make a copy incase resize moves the element.</span>
<a name="l00464"></a>00464             reserve(<a class="code" href="group__selection__algorithms.html#g7c5bdb55e42beda2cd6acbe643ef4fa2">size</a>() ? 2 * <a class="code" href="group__selection__algorithms.html#g7c5bdb55e42beda2cd6acbe643ef4fa2">size</a>() : 3);
<a name="l00465"></a>00465             <span class="keywordflow">return</span> unsafe_copy_insert(tmp);
<a name="l00466"></a>00466         }
<a name="l00467"></a>00467         <span class="keywordflow">return</span> unsafe_copy_insert(x);
<a name="l00468"></a>00468     }
<a name="l00469"></a>00469     
<a name="l00470"></a>00470     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;
<a name="l00471"></a><a class="code" href="classadobe_1_1closed__hash__set.html#c8f3af1bb4b3d589571cf9894f88d6d6">00471</a>     std::pair&lt;iterator, bool&gt; <a class="code" href="group__sequence__model__concept.html#gea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(U x, <span class="keyword">typename</span> <a class="code" href="structadobe_1_1move__sink.html" title="move_sink and copy_sink are used to select between overloaded operations according...">move_sink&lt;U, value_type&gt;::type</a> = 0)
<a name="l00472"></a>00472     {
<a name="l00473"></a>00473         <span class="keywordflow">if</span> (capacity() == <a class="code" href="group__selection__algorithms.html#g7c5bdb55e42beda2cd6acbe643ef4fa2">size</a>()) reserve(<a class="code" href="group__selection__algorithms.html#g7c5bdb55e42beda2cd6acbe643ef4fa2">size</a>() ? 2 * <a class="code" href="group__selection__algorithms.html#g7c5bdb55e42beda2cd6acbe643ef4fa2">size</a>() : 3);
<a name="l00474"></a>00474         
<a name="l00475"></a>00475         <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> node = bucket(key_function()(x));
<a name="l00476"></a>00476         
<a name="l00477"></a>00477         <span class="keywordflow">switch</span> (node.state())
<a name="l00478"></a>00478         {
<a name="l00479"></a>00479         <span class="keywordflow">case</span> state_home:
<a name="l00480"></a>00480             {
<a name="l00481"></a>00481             <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> found = <a class="code" href="group__find.html#g3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(node, key_function()(x));
<a name="l00482"></a>00482             <span class="keywordflow">if</span> (found != end()) {
<a name="l00483"></a>00483                 *found = <a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(x);
<a name="l00484"></a>00484                 <span class="keywordflow">return</span> <a class="code" href="group__asl__pair.html#g86cec50e4c5771ecd54930cc50dedcfd">std::make_pair</a>(found, <span class="keyword">false</span>);
<a name="l00485"></a>00485             }
<a name="l00486"></a>00486             
<a name="l00487"></a>00487             <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> free(begin_free());
<a name="l00488"></a>00488             insert_raw(free, <a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(x), state_misplaced);
<a name="l00489"></a>00489             <a class="code" href="group__adobe__iterator.html#g38d33c4c128cae32602cefd55503a6d2">unsafe::splice_node_range</a>(node, free, free);
<a name="l00490"></a>00490             node = free;
<a name="l00491"></a>00491             }
<a name="l00492"></a>00492             <span class="keywordflow">break</span>;
<a name="l00493"></a>00493         <span class="keywordflow">case</span> state_misplaced:
<a name="l00494"></a>00494             {
<a name="l00495"></a>00495             <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> free(begin_free());
<a name="l00496"></a>00496             insert_raw(free, <a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(*node), state_misplaced);
<a name="l00497"></a>00497             
<a name="l00498"></a>00498             <a class="code" href="group__adobe__iterator.html#g5f4d1f99bf3aae004dd736f8a3fdb999">unsafe::set_next</a>(boost::prior(node), free);
<a name="l00499"></a>00499             <a class="code" href="group__adobe__iterator.html#g5f4d1f99bf3aae004dd736f8a3fdb999">unsafe::set_next</a>(free, boost::next(node));
<a name="l00500"></a>00500             
<a name="l00501"></a>00501             erase_raw(node);
<a name="l00502"></a>00502             }
<a name="l00503"></a>00503             <span class="comment">// fall through</span>
<a name="l00504"></a>00504         <span class="keywordflow">default</span>: <span class="comment">// state_free</span>
<a name="l00505"></a>00505             {
<a name="l00506"></a>00506             insert_raw(node, <a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(x), state_home);
<a name="l00507"></a>00507             <a class="code" href="group__adobe__iterator.html#g38d33c4c128cae32602cefd55503a6d2">unsafe::splice_node_range</a>(end(), node, node);
<a name="l00508"></a>00508             }
<a name="l00509"></a>00509         }
<a name="l00510"></a>00510         header()-&gt;size() += 1;
<a name="l00511"></a>00511         <span class="keywordflow">return</span> <a class="code" href="group__asl__pair.html#g86cec50e4c5771ecd54930cc50dedcfd">std::make_pair</a>(node, <span class="keyword">true</span>);
<a name="l00512"></a>00512     }
<a name="l00513"></a>00513     
<a name="l00514"></a>00514     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;
<a name="l00515"></a><a class="code" href="classadobe_1_1closed__hash__set.html#c268e1d2640382b873d32ab3c2c8fab5">00515</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> <a class="code" href="group__sequence__model__concept.html#gea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(<a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a>, <span class="keyword">const</span> U&amp; x, <span class="keyword">typename</span> <a class="code" href="structadobe_1_1copy__sink.html" title="copy_sink and move_sink are used to select between overloaded operations according...">copy_sink&lt;U, value_type&gt;::type</a> = 0)
<a name="l00516"></a>00516     {
<a name="l00517"></a>00517         <span class="keywordflow">return</span> <a class="code" href="group__sequence__model__concept.html#gea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(x).first;
<a name="l00518"></a>00518     }
<a name="l00519"></a>00519     
<a name="l00520"></a>00520     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;
<a name="l00521"></a><a class="code" href="classadobe_1_1closed__hash__set.html#3c9130573d856a79c9fc2ca41b47b788">00521</a>     <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> <a class="code" href="group__sequence__model__concept.html#gea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(<a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a>, U x, <span class="keyword">typename</span> <a class="code" href="structadobe_1_1move__sink.html" title="move_sink and copy_sink are used to select between overloaded operations according...">move_sink&lt;U, value_type&gt;::type</a> = 0)
<a name="l00522"></a>00522     {
<a name="l00523"></a>00523         <span class="keywordflow">return</span> <a class="code" href="group__sequence__model__concept.html#gea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(<a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(x)).first;
<a name="l00524"></a>00524     }
<a name="l00525"></a>00525     
<a name="l00526"></a><a class="code" href="classadobe_1_1closed__hash__set.html#4cea53c913040da9b4d84e77eb7844cd">00526</a>     ~<a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>()
<a name="l00527"></a>00527     {
<a name="l00528"></a>00528         <span class="keywordflow">if</span> (header())
<a name="l00529"></a>00529         {
<a name="l00530"></a>00530             <span class="keywordflow">for</span>(<a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">iterator</a> first(begin()), last(end()); first != last; ++first) <a class="code" href="namespaceadobe.html#5552b0f660612c91fd30793df8d06091">destroy</a>(&amp;*first);
<a name="l00531"></a>00531             raw_allocator alloc(get_allocator());
<a name="l00532"></a>00532             alloc.deallocate(reinterpret_cast&lt;char*&gt;(header()), 0);
<a name="l00533"></a>00533         }
<a name="l00534"></a>00534     }
<a name="l00535"></a>00535         
<a name="l00536"></a><a class="code" href="classadobe_1_1closed__hash__set.html#bc575ac3431045320d145610382a3011">00536</a>     <span class="keyword">friend</span> <span class="keywordtype">void</span> <a class="code" href="namespaceadobe.html#5c6656b2ba51d81c71a97670f3b15a83">swap</a>(<a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>&amp; x, <a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>&amp; y)
<a name="l00537"></a>00537     {
<a name="l00538"></a>00538         <a class="code" href="namespaceadobe.html#5c6656b2ba51d81c71a97670f3b15a83">std::swap</a>(x.data_m, y.data_m);
<a name="l00539"></a>00539     }
<a name="l00540"></a>00540     
<a name="l00541"></a><a class="code" href="classadobe_1_1closed__hash__set.html#9266b5954937bd5257be1f6484b3f16c">00541</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespaceadobe.html#a70510cd533bc8e226d58fc472ca1f6b">operator==</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>&amp; y)
<a name="l00542"></a>00542     {
<a name="l00543"></a>00543         <span class="keywordflow">if</span> (x.<a class="code" href="classadobe_1_1closed__hash__set.html#503ab01f6c0142145d3434f6924714e7">size</a>() != y.<a class="code" href="classadobe_1_1closed__hash__set.html#503ab01f6c0142145d3434f6924714e7">size</a>()) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00544"></a>00544         <span class="keywordflow">for</span> (<a class="code" href="classadobe_1_1closed__hash__set.html#96af92cff83ecc57d226f5e3df7f173b">const_iterator</a> first(x.<a class="code" href="classadobe_1_1closed__hash__set.html#d69bd11391be1a1dba5c8202259664f8">begin</a>()), last(x.<a class="code" href="classadobe_1_1closed__hash__set.html#cad38d52497a975bfb6f2f6acd76631f">end</a>()); first != last; ++first)
<a name="l00545"></a>00545         {
<a name="l00546"></a>00546             <a class="code" href="classadobe_1_1closed__hash__set.html#96af92cff83ecc57d226f5e3df7f173b">const_iterator</a> <a class="code" href="structadobe_1_1iter.html">iter</a>(y.<a class="code" href="classadobe_1_1closed__hash__set.html#dc204502ef1606c9daa4a613da6aacfb">find</a>(y.<a class="code" href="classadobe_1_1closed__hash__set.html#67dbb7e2ef73eef7948ffcea921d6d56">key_function</a>()(*first)));
<a name="l00547"></a>00547             <span class="keywordflow">if</span> (iter == y.<a class="code" href="classadobe_1_1closed__hash__set.html#cad38d52497a975bfb6f2f6acd76631f">end</a>() || !(*first == *iter)) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00548"></a>00548         }
<a name="l00549"></a>00549         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00550"></a>00550     }
<a name="l00551"></a>00551  <span class="keyword">private</span>:
<a name="l00552"></a>00552  
<a name="l00553"></a>00553     <span class="keyword">typedef</span> <span class="keyword">typename</span> allocator_type::template rebind&lt;char&gt;::other raw_allocator;
<a name="l00554"></a>00554 
<a name="l00555"></a>00555 
<a name="l00556"></a>00556     <span class="keywordtype">void</span> allocate(<span class="keyword">const</span> allocator_type&amp; a, size_type n)
<a name="l00557"></a>00557     {
<a name="l00558"></a>00558         <span class="comment">// table of primes such that p[n + 1] = next_prime(2 * p[n])</span>
<a name="l00559"></a>00559     
<a name="l00560"></a>00560         <span class="keyword">static</span> <span class="keyword">const</span> std::size_t prime_table[] = { 3UL, 7UL, 17UL, 37UL, 79UL, 163UL, 331UL, 673UL,
<a name="l00561"></a>00561             1361UL, 2729UL, 5471UL, 10949UL, 21911UL, 43853UL, 87719UL, 175447UL, 350899UL,
<a name="l00562"></a>00562             701819UL, 1403641UL, 2807303UL, 5614657UL, 11229331UL, 22458671UL, 44917381UL,
<a name="l00563"></a>00563             89834777UL, 179669557UL, 359339171UL, 718678369UL, 1437356741UL, 2874713497UL,
<a name="l00564"></a>00564             ULONG_MAX
<a name="l00565"></a>00565         };
<a name="l00566"></a>00566 
<a name="l00567"></a>00567         assert(!header() &amp;&amp; <span class="stringliteral">"WARNING (sparent@adobe.com) : About to write over allocated header."</span>);
<a name="l00568"></a>00568 
<a name="l00569"></a>00569         <span class="keywordflow">if</span> (n == 0 &amp;&amp; a == allocator_type()) <span class="keywordflow">return</span>;
<a name="l00570"></a>00570 
<a name="l00571"></a>00571         n = *<a class="code" href="namespaceadobe_1_1fn.html#59e44aef9c93131146606040c0b15e38">adobe::lower_bound</a>(prime_table, n);
<a name="l00572"></a>00572             
<a name="l00573"></a>00573         raw_allocator alloc(a);
<a name="l00574"></a>00574     
<a name="l00575"></a>00575         header() = <span class="keyword">reinterpret_cast&lt;</span>header_t*<span class="keyword">&gt;</span>(alloc.allocate(<span class="keyword">sizeof</span>(header_t) - <span class="keyword">sizeof</span>(node_t)
<a name="l00576"></a>00576             + <span class="keyword">sizeof</span>(node_t) * n));
<a name="l00577"></a>00577         header()-&gt;capacity() = n;
<a name="l00578"></a>00578         header()-&gt;size() = 0;
<a name="l00579"></a>00579         <a class="code" href="namespaceadobe.html#2983facbc34f8d51a4e29b8965d4c661">construct</a>(&amp;header()-&gt;free_tail());
<a name="l00580"></a>00580         <a class="code" href="namespaceadobe.html#2983facbc34f8d51a4e29b8965d4c661">construct</a>(&amp;header()-&gt;used_tail());
<a name="l00581"></a>00581         <a class="code" href="namespaceadobe.html#2983facbc34f8d51a4e29b8965d4c661">construct</a>(&amp;header()-&gt;allocator(), a);
<a name="l00582"></a>00582         
<a name="l00583"></a>00583         node_t* prior = header()-&gt;free_tail().address();
<a name="l00584"></a>00584         <span class="keywordflow">for</span> (node_ptr first(&amp;header()-&gt;storage_m[0]), last(&amp;header()-&gt;storage_m[0]+ n);
<a name="l00585"></a>00585                 first != last; ++first)
<a name="l00586"></a>00586         {
<a name="l00587"></a>00587             set_next_raw(*prior, *first);
<a name="l00588"></a>00588             prior = first;
<a name="l00589"></a>00589             <span class="comment">// first-&gt;set_state(state_free);</span>
<a name="l00590"></a>00590         }
<a name="l00591"></a>00591         set_next_raw(*prior, header()-&gt;free_tail());
<a name="l00592"></a>00592 
<a name="l00593"></a>00593     }
<a name="l00594"></a>00594  
<a name="l00595"></a>00595     iterator bucket(<span class="keyword">const</span> <a class="code" href="namespaceadobe.html#0b1e8c11782fffe95a8e4a50790be36e">key_type</a>&amp; key)
<a name="l00596"></a>00596     {
<a name="l00597"></a>00597         std::size_t slot(hash_function()(key) % capacity());
<a name="l00598"></a>00598         <span class="keywordflow">return</span> iterator(&amp;header()-&gt;storage_m[0] + slot);
<a name="l00599"></a>00599     }
<a name="l00600"></a>00600  
<a name="l00601"></a>00601     iterator <a class="code" href="group__find.html#g3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(iterator node, <span class="keyword">const</span> <a class="code" href="namespaceadobe.html#0b1e8c11782fffe95a8e4a50790be36e">key_type</a>&amp; key)
<a name="l00602"></a>00602     {
<a name="l00603"></a>00603         <span class="keywordflow">do</span>
<a name="l00604"></a>00604         {
<a name="l00605"></a>00605             <span class="keywordflow">if</span> (key_eq()(key, key_function()(*node))) <span class="keywordflow">return</span> node;
<a name="l00606"></a>00606             ++node;
<a name="l00607"></a>00607         } <span class="keywordflow">while</span> ((node != end()) &amp;&amp; (node.state() != std::size_t(state_home)));
<a name="l00608"></a>00608         
<a name="l00609"></a>00609         <span class="keywordflow">return</span> end();
<a name="l00610"></a>00610     }
<a name="l00611"></a>00611  
<a name="l00612"></a>00612     <span class="comment">// location points to a free node</span>
<a name="l00613"></a>00613     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;
<a name="l00614"></a>00614     <span class="keyword">static</span> <span class="keywordtype">void</span> insert_raw(iterator location, <span class="keyword">const</span> U&amp; x, std::size_t state,
<a name="l00615"></a>00615         <span class="keyword">typename</span> copy_sink&lt;U, value_type&gt;::type = 0)
<a name="l00616"></a>00616     {
<a name="l00617"></a>00617         ::new (&amp;(*location)) value_type(x);
<a name="l00618"></a>00618         location.set_state(state);
<a name="l00619"></a>00619         <a class="code" href="group__adobe__iterator.html#g3adeba343a28c39563dc4aae37f22421">unsafe::skip_node</a>(location);
<a name="l00620"></a>00620     }
<a name="l00621"></a>00621  
<a name="l00622"></a>00622     <span class="comment">// location points to a free node</span>
<a name="l00623"></a>00623     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;
<a name="l00624"></a>00624     <span class="keyword">static</span> <span class="keywordtype">void</span> insert_raw(iterator location, U x, std::size_t state,
<a name="l00625"></a>00625         <span class="keyword">typename</span> move_sink&lt;U, value_type&gt;::type = 0)
<a name="l00626"></a>00626     {
<a name="l00627"></a>00627         move_construct&lt;value_type&gt;(&amp;*location, x);
<a name="l00628"></a>00628         location.set_state(state);
<a name="l00629"></a>00629         <a class="code" href="group__adobe__iterator.html#g3adeba343a28c39563dc4aae37f22421">unsafe::skip_node</a>(location);
<a name="l00630"></a>00630     }
<a name="l00631"></a>00631     
<a name="l00632"></a>00632     <span class="comment">// location points to a used but detatched node</span>
<a name="l00633"></a>00633     <span class="keywordtype">void</span> erase_raw(iterator location)
<a name="l00634"></a>00634     {
<a name="l00635"></a>00635         <a class="code" href="namespaceadobe.html#5552b0f660612c91fd30793df8d06091">destroy</a>(&amp;*location);
<a name="l00636"></a>00636         location.set_state(state_free);
<a name="l00637"></a>00637         <a class="code" href="group__adobe__iterator.html#g38d33c4c128cae32602cefd55503a6d2">unsafe::splice_node_range</a>(end_free(), location, location);
<a name="l00638"></a>00638     }
<a name="l00639"></a>00639  
<a name="l00640"></a>00640     iterator begin_free() { <span class="keywordflow">return</span> iterator(header() ? header()-&gt;free_tail().next() : 0); }
<a name="l00641"></a>00641     iterator end_free() { <span class="keywordflow">return</span> iterator(header() ? header()-&gt;free_tail().address() : 0); }
<a name="l00642"></a>00642 
<a name="l00643"></a>00643 
<a name="l00644"></a>00644     std::pair&lt;iterator, bool&gt; unsafe_copy_insert(<span class="keyword">const</span> value_type&amp; x)
<a name="l00645"></a>00645     {
<a name="l00646"></a>00646         <span class="comment">// pre-condition is that there is capacity for the element.</span>
<a name="l00647"></a>00647         iterator node = bucket(key_function()(x));
<a name="l00648"></a>00648         
<a name="l00649"></a>00649         <span class="keywordflow">switch</span> (node.state())
<a name="l00650"></a>00650         {
<a name="l00651"></a>00651         <span class="keywordflow">case</span> state_home:
<a name="l00652"></a>00652             {
<a name="l00653"></a>00653             iterator found = <a class="code" href="group__find.html#g3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(node, key_function()(x));
<a name="l00654"></a>00654             <span class="keywordflow">if</span> (found != end()) {
<a name="l00655"></a>00655                 *found = x;
<a name="l00656"></a>00656                 <span class="keywordflow">return</span> <a class="code" href="group__asl__pair.html#g86cec50e4c5771ecd54930cc50dedcfd">std::make_pair</a>(found, <span class="keyword">false</span>);
<a name="l00657"></a>00657             }
<a name="l00658"></a>00658             
<a name="l00659"></a>00659             iterator free(begin_free());
<a name="l00660"></a>00660             insert_raw(free, x, state_misplaced);
<a name="l00661"></a>00661             <a class="code" href="group__adobe__iterator.html#g38d33c4c128cae32602cefd55503a6d2">unsafe::splice_node_range</a>(node, free, free);
<a name="l00662"></a>00662             node = free;
<a name="l00663"></a>00663             }
<a name="l00664"></a>00664             <span class="keywordflow">break</span>;
<a name="l00665"></a>00665         <span class="keywordflow">case</span> state_misplaced:
<a name="l00666"></a>00666             {
<a name="l00667"></a>00667             iterator free(begin_free());
<a name="l00668"></a>00668             insert_raw(free, *node, state_misplaced);
<a name="l00669"></a>00669             
<a name="l00670"></a>00670             <a class="code" href="group__adobe__iterator.html#g5f4d1f99bf3aae004dd736f8a3fdb999">unsafe::set_next</a>(boost::prior(node), free);
<a name="l00671"></a>00671             <a class="code" href="group__adobe__iterator.html#g5f4d1f99bf3aae004dd736f8a3fdb999">unsafe::set_next</a>(free, boost::next(node));
<a name="l00672"></a>00672             
<a name="l00673"></a>00673             erase_raw(node);
<a name="l00674"></a>00674             }
<a name="l00675"></a>00675             <span class="comment">// fall through</span>
<a name="l00676"></a>00676         <span class="keywordflow">default</span>: <span class="comment">// state_free</span>
<a name="l00677"></a>00677             {
<a name="l00678"></a>00678             insert_raw(node, x, state_home);
<a name="l00679"></a>00679             <a class="code" href="group__adobe__iterator.html#g38d33c4c128cae32602cefd55503a6d2">unsafe::splice_node_range</a>(end(), node, node);
<a name="l00680"></a>00680             }
<a name="l00681"></a>00681         }
<a name="l00682"></a>00682         header()-&gt;size() += 1;
<a name="l00683"></a>00683         <span class="keywordflow">return</span> <a class="code" href="group__asl__pair.html#g86cec50e4c5771ecd54930cc50dedcfd">std::make_pair</a>(node, <span class="keyword">true</span>);
<a name="l00684"></a>00684     }
<a name="l00685"></a>00685 
<a name="l00686"></a>00686 };
<a name="l00687"></a>00687 
<a name="l00688"></a>00688 <span class="comment">/*************************************************************************************************/</span>
<a name="l00689"></a>00689 
<a name="l00708"></a>00708 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key,
<a name="l00709"></a>00709          <span class="keyword">typename</span> T,
<a name="l00710"></a>00710          <span class="keyword">typename</span> Hash,
<a name="l00711"></a>00711          <span class="keyword">typename</span> Pred,
<a name="l00712"></a>00712          <span class="keyword">typename</span> A&gt;
<a name="l00713"></a><a class="code" href="classadobe_1_1closed__hash__map.html">00713</a> <span class="keyword">class </span><a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a> : <span class="keyword">public</span> <a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set</a>&lt;pair&lt;Key, T&gt;,
<a name="l00714"></a>00714                                                get_element&lt;0, pair&lt;Key, T&gt; &gt;,
<a name="l00715"></a>00715                                                Hash,
<a name="l00716"></a>00716                                                Pred,
<a name="l00717"></a>00717                                                A&gt;
<a name="l00718"></a>00718 {
<a name="l00719"></a>00719     <span class="keyword">typedef</span> <a class="code" href="classadobe_1_1closed__hash__set.html" title="A hash based associative container.">closed_hash_set&lt;pair&lt;Key, T&gt;</a>,
<a name="l00720"></a>00720                             <a class="code" href="structadobe_1_1get__element.html">get_element&lt;0, pair&lt;Key, T&gt;</a> &gt;,
<a name="l00721"></a>00721                             Hash,
<a name="l00722"></a>00722                             Pred,
<a name="l00723"></a>00723                             A&gt; <a class="code" href="classadobe_1_1closed__hash__set.html">set_type</a>;
<a name="l00724"></a>00724  <span class="keyword">public</span>:
<a name="l00725"></a><a class="code" href="classadobe_1_1closed__hash__map.html#818fd380a9a028f2447a0410086e0d5a">00725</a>     <span class="keyword">typedef</span> T mapped_type;
<a name="l00726"></a>00726  
<a name="l00727"></a><a class="code" href="classadobe_1_1closed__hash__map.html#d3c2e1056e5bd90c8883f1411b0c63f5">00727</a>     <a class="code" href="classadobe_1_1closed__hash__map.html#d3c2e1056e5bd90c8883f1411b0c63f5">closed_hash_map</a>() { }
<a name="l00728"></a>00728     
<a name="l00729"></a>00729     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt; <span class="comment">// I models InputIterator</span>
<a name="l00730"></a><a class="code" href="classadobe_1_1closed__hash__map.html#2f72f6d51949931b7ad4df1c4ddd338d">00730</a>     <a class="code" href="classadobe_1_1closed__hash__map.html#2f72f6d51949931b7ad4df1c4ddd338d">closed_hash_map</a>(I f, I l) : <a class="code" href="classadobe_1_1closed__hash__set.html">set_type</a>(f, l) { }
<a name="l00731"></a>00731     
<a name="l00732"></a>00732 <span class="preprocessor">#if 0</span>
<a name="l00733"></a>00733 <span class="preprocessor"></span>    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt; <span class="comment">// I models ForwardIterator</span>
<a name="l00734"></a>00734     <a class="code" href="namespaceadobe.html#07e1ab8f8ec0603377b4d89bfa9b9bae">closed_hash_map</a>(I f, I l, move_ctor) : set_type(f, l, move_ctor()) { }
<a name="l00735"></a>00735 <span class="preprocessor">#endif</span>
<a name="l00736"></a>00736 <span class="preprocessor"></span>        
<a name="l00737"></a><a class="code" href="classadobe_1_1closed__hash__map.html#09fc6de1695ae65f7fd182ef6609aad2">00737</a>     <a class="code" href="classadobe_1_1closed__hash__map.html#09fc6de1695ae65f7fd182ef6609aad2">closed_hash_map</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a>&amp; x) : <a class="code" href="classadobe_1_1closed__hash__set.html">set_type</a>(x) { }
<a name="l00738"></a><a class="code" href="classadobe_1_1closed__hash__map.html#01ebdafce2e5d9acadad763521f0df8f">00738</a>     <a class="code" href="classadobe_1_1closed__hash__map.html#01ebdafce2e5d9acadad763521f0df8f">closed_hash_map</a>(<a class="code" href="structadobe_1_1move__from.html" title="move_from is used for move_ctors.">move_from&lt;closed_hash_map&gt;</a> x) : <a class="code" href="classadobe_1_1closed__hash__set.html">set_type</a>(<a class="code" href="structadobe_1_1move__from.html" title="move_from is used for move_ctors.">move_from</a>&lt;<a class="code" href="classadobe_1_1closed__hash__set.html">set_type</a>&gt;(x.source)) { }
<a name="l00739"></a><a class="code" href="classadobe_1_1closed__hash__map.html#e840c11fac3bbec9dbe0c01042ae0ffe">00739</a>     <a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a>&amp; operator=(<a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a> x)
<a name="l00740"></a>00740     { <a class="code" href="namespaceadobe.html#5c6656b2ba51d81c71a97670f3b15a83">swap</a>(x, *<span class="keyword">this</span>); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00741"></a>00741             
<a name="l00742"></a><a class="code" href="classadobe_1_1closed__hash__map.html#e987b563c2c9de12da41af5fd1772bd5">00742</a>     <span class="keyword">friend</span> <span class="keywordtype">void</span> <a class="code" href="namespaceadobe.html#5c6656b2ba51d81c71a97670f3b15a83">swap</a>(<a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a>&amp; x, <a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a>&amp; y)
<a name="l00743"></a>00743     { <a class="code" href="classadobe_1_1closed__hash__map.html#e987b563c2c9de12da41af5fd1772bd5">swap</a>(static_cast&lt;set_type&amp;&gt;(x), static_cast&lt;set_type&amp;&gt;(y)); }
<a name="l00744"></a>00744     
<a name="l00745"></a>00745     
<a name="l00746"></a><a class="code" href="classadobe_1_1closed__hash__map.html#ad4363c6218148569be71f78b81df94e">00746</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespaceadobe.html#a70510cd533bc8e226d58fc472ca1f6b">operator==</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a>&amp; y)
<a name="l00747"></a>00747     { <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classadobe_1_1closed__hash__set.html">set_type</a>&amp;<span class="keyword">&gt;</span>(x) == static_cast&lt;const set_type&amp;&gt;(y); }
<a name="l00748"></a>00748     
<a name="l00749"></a>00749     <span class="comment">/*</span>
<a name="l00750"></a>00750 <span class="comment">        NOTE (sparent) : Can't use boost::equality_comparable without introducing extra base class</span>
<a name="l00751"></a>00751 <span class="comment">        overhead.</span>
<a name="l00752"></a>00752 <span class="comment">    */</span>
<a name="l00753"></a>00753     
<a name="l00754"></a><a class="code" href="classadobe_1_1closed__hash__map.html#1641788f2d13e2e0dcf1f30daa97a7e8">00754</a>     <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespaceadobe.html#1048ea807626add40ae9a2800c1b6a5f">operator!=</a>(<span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a>&amp; x, <span class="keyword">const</span> <a class="code" href="classadobe_1_1closed__hash__map.html" title="A hash based associative container.">closed_hash_map</a>&amp; y)
<a name="l00755"></a>00755     { <span class="keywordflow">return</span> !(x == y); }
<a name="l00756"></a>00756 
<a name="l00757"></a>00757 <span class="preprocessor">#ifndef ADOBE_CLOSED_HASH_MAP_INDEX</span>
<a name="l00758"></a><a class="code" href="closed__hash_8hpp.html#98bd3002bce0c0babe79b0cf52869936">00758</a> <span class="preprocessor"></span><span class="preprocessor">#define ADOBE_CLOSED_HASH_MAP_INDEX 1</span>
<a name="l00759"></a>00759 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00760"></a>00760 <span class="preprocessor"></span>
<a name="l00761"></a>00761 <span class="preprocessor">#if ADOBE_CLOSED_HASH_MAP_INDEX</span>
<a name="l00762"></a>00762 <span class="preprocessor"></span>        
<a name="l00763"></a><a class="code" href="classadobe_1_1closed__hash__map.html#46d61d9c198c63e2a750811e839e506f">00763</a>     mapped_type&amp; operator[](<span class="keyword">const</span> Key&amp; x)
<a name="l00764"></a>00764     {
<a name="l00765"></a>00765         <span class="keyword">typename</span> <a class="code" href="classadobe_1_1closed__hash__set.html#a9317c7f86e5fbf136dfeddeb2fb0d50">set_type::iterator</a> i = this-&gt;<a class="code" href="group__find.html#g3ca10f4d1b45a1648140f00ef752bad3" title="find implementation">find</a>(x);
<a name="l00766"></a>00766         <span class="keywordflow">if</span> (i == this-&gt;end()) <span class="keywordflow">return</span> <a class="code" href="group__sequence__model__concept.html#gea144a9d3e3dad3f7ffa9cd5b538b386" title="SequenceModel concept requirement.">insert</a>(<a class="code" href="group__asl__pair.html#g86cec50e4c5771ecd54930cc50dedcfd">adobe::make_pair</a>(x, mapped_type())).first-&gt;second;
<a name="l00767"></a>00767         <span class="keywordflow">return</span> i-&gt;second;
<a name="l00768"></a>00768     }
<a name="l00769"></a>00769     
<a name="l00770"></a>00770 <span class="preprocessor">#endif</span>
<a name="l00771"></a>00771 <span class="preprocessor"></span>};
<a name="l00772"></a>00772 
<a name="l00773"></a>00773 <span class="comment">/*************************************************************************************************/</span>
<a name="l00774"></a>00774 
<a name="l00775"></a>00775 <a class="code" href="namespaceadobe.html#0d19002ca08b6fc1baf4fad3522925c3">BOOST_STATIC_ASSERT</a>(<span class="keyword">sizeof</span>(closed_hash_set&lt;int&gt;) == <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*));
<a name="l00776"></a>00776 
<a name="l00777"></a>00777 
<a name="l00778"></a>00778 <span class="preprocessor">#ifndef ADOBE_NO_DOCUMENTATION</span>
<a name="l00779"></a>00779 <span class="preprocessor"></span>
<a name="l00780"></a>00780 } <span class="comment">// namespace version_1</span>
<a name="l00781"></a>00781 
<a name="l00782"></a>00782 <span class="preprocessor">#endif</span>
<a name="l00783"></a>00783 <span class="preprocessor"></span>
<a name="l00784"></a>00784 <span class="comment">/*************************************************************************************************/</span>
<a name="l00785"></a>00785 
<a name="l00786"></a>00786 } <span class="comment">// namespace adobe</span>
<a name="l00787"></a>00787 
<a name="l00788"></a>00788 <span class="comment">/*************************************************************************************************/</span>
<a name="l00789"></a>00789 
<a name="l00790"></a>00790 <a class="code" href="group__type__info__related.html#gc7fc230df70a262b176a5c198a265c55" title="Register a type for use with manual adobe::version_1::type_info_t . This integer...">ADOBE_NAME_TYPE_1</a>(<span class="stringliteral">"closed_hash_set:version_1:adobe"</span>,
<a name="l00791"></a>00791     <a class="code" href="group__abi__container.html#g123a2e265d9c35109e121cb70b865f18">adobe::version_1::closed_hash_set</a>&lt;T0, <a class="code" href="structadobe_1_1identity.html">adobe::identity&lt;const T0&gt;</a>, boost::hash&lt;T0&gt;, std::equal_to&lt;T0&gt;,
<a name="l00792"></a>00792         adobe::capture_allocator&lt;T0&gt; &gt;);
<a name="l00793"></a>00793 <a class="code" href="group__type__info__related.html#g2903ecd2afe49015f3a82a36cfc295af" title="Register a type for use with manual adobe::version_1::type_info_t . This integer...">ADOBE_NAME_TYPE_2</a>(<span class="stringliteral">"closed_hash_map:version_1:adobe"</span>,
<a name="l00794"></a>00794     <a class="code" href="namespaceadobe.html#07e1ab8f8ec0603377b4d89bfa9b9bae">adobe::version_1::closed_hash_map</a>&lt;T0, T1, boost::hash&lt;T0&gt;, std::equal_to&lt;T0&gt;,
<a name="l00795"></a>00795             adobe::capture_allocator&lt;<a class="code" href="structadobe_1_1pair.html">adobe::pair&lt;T0, T1&gt;</a> &gt; &gt;);
<a name="l00796"></a>00796 
<a name="l00797"></a>00797 <a class="code" href="group__type__info__related.html#g78080b90cf4dc9ee58a0f15b8c1fdd67" title="Register a type for use with manual adobe::version_1::type_info_t . This integer...">ADOBE_NAME_TYPE_5</a>(<span class="stringliteral">"closed_hash_set:version_1:adobe"</span>,
<a name="l00798"></a>00798     adobe::version_1::closed_hash_set&lt;T0, T1, T2, T3, T4 &gt;);
<a name="l00799"></a>00799 <a class="code" href="group__type__info__related.html#g78080b90cf4dc9ee58a0f15b8c1fdd67" title="Register a type for use with manual adobe::version_1::type_info_t . This integer...">ADOBE_NAME_TYPE_5</a>(<span class="stringliteral">"closed_hash_map:version_1:adobe"</span>,
<a name="l00800"></a>00800     adobe::version_1::closed_hash_map&lt;T0, T1, T2, T3, T4 &gt;);
<a name="l00801"></a>00801 
<a name="l00802"></a>00802 <span class="comment">/*************************************************************************************************/</span>
<a name="l00803"></a>00803 
<a name="l00804"></a>00804 <span class="keyword">namespace </span>boost {
<a name="l00805"></a>00805 
<a name="l00806"></a>00806 <span class="keyword">template</span>&lt;   <span class="keyword">typename</span> T,
<a name="l00807"></a>00807             <span class="keyword">typename</span> KeyTransform,
<a name="l00808"></a>00808             <span class="keyword">typename</span> Hash,
<a name="l00809"></a>00809             <span class="keyword">typename</span> Pred,
<a name="l00810"></a>00810             <span class="keyword">typename</span> A&gt;
<a name="l00811"></a><a class="code" href="structboost_1_1has__nothrow__constructor_3_01adobe_1_1version__1_1_1closed__hash__set_3_01T_00_00cbb81074f838e5f10556d135efe1cf8.html">00811</a> <span class="keyword">struct </span>has_nothrow_constructor&lt;adobe::version_1::<a class="code" href="group__abi__container.html#g123a2e265d9c35109e121cb70b865f18">closed_hash_set</a>&lt;T, KeyTransform, Hash, Pred, A&gt; &gt;
<a name="l00812"></a>00812         : boost::mpl::true_ { };
<a name="l00813"></a>00813 
<a name="l00814"></a>00814 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key,
<a name="l00815"></a>00815          <span class="keyword">typename</span> T,
<a name="l00816"></a>00816          <span class="keyword">typename</span> Hash,
<a name="l00817"></a>00817          <span class="keyword">typename</span> Pred,
<a name="l00818"></a>00818          <span class="keyword">typename</span> A&gt;
<a name="l00819"></a><a class="code" href="structboost_1_1has__nothrow__constructor_3_01adobe_1_1version__1_1_1closed__hash__map_3_01Key_008b22857affbb01c8b29547d7855d52f1.html">00819</a> <span class="keyword">struct </span>has_nothrow_constructor&lt;adobe::version_1::<a class="code" href="namespaceadobe.html#07e1ab8f8ec0603377b4d89bfa9b9bae">closed_hash_map</a>&lt;Key, T, Hash, Pred, A&gt; &gt;
<a name="l00820"></a>00820     : boost::mpl::true_ { };
<a name="l00821"></a>00821 
<a name="l00822"></a>00822 } <span class="comment">// namespace boost</span>
<a name="l00823"></a>00823 
<a name="l00824"></a>00824 <span class="comment">/*************************************************************************************************/</span>
<a name="l00825"></a>00825 
<a name="l00826"></a>00826 <span class="preprocessor">#endif</span>
<a name="l00827"></a>00827 <span class="preprocessor"></span>
<a name="l00828"></a>00828 <span class="comment">/*************************************************************************************************/</span>
</pre></div></div>

<!-- Begin Footer -->
</td></tr>
</table>
</div> <!-- content -->
<div class='footerdiv'>
    <div id='footersub'>
        <ul>
            <li><a href="http://www.adobe.com/go/gftray_foot_aboutadobe">Company</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_contact_adobe">Contact Us</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_accessibility">Accessibility</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_report_piracy">Report Piracy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_permissions_trademarks">Permissions &amp; Trademarks</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_product_license_agreements">Product License Agreements</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_feedback">Send Feedback</a></li>
        </ul>
        <div>
            <p>Copyright &#169; 2006-2007 Adobe Systems Incorporated.</p>
            <p>Use of this website signifies your agreement to the <a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a> and <a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>.</p>
            <p>Search powered by <a href="http://www.google.com/" target="new">Google</a></p>
        </div>
	</div>
</div>
<script type="text/javascript">
_uacct = "UA-396569-1";
urchinTracker();
</script>
</body>
</html>
