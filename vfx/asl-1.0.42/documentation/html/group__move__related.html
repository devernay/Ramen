<!--
    Copyright 2005-2008 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <TITLE>Adobe Software Technology Lab: Move Library</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="stlab.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
</head>
<body>
<div id='content'>
<table><tr>
<td colspan='5'>
    <div id='opensource_banner'>
    <table style='width: 100%; padding: 5px;'><tr>
    <td align='left'>
        <a href='index.html' style='border: none'><img src='stlab2007.jpg' alt="stlab.adobe.com"/></a>
    </td>
    <td align='right'>
        <a href='http://www.adobe.com' style='border: none'><img src='adobe_hlogo.gif' alt="Adobe Systems Incorporated"/></a>
    </td>
    </tr></table>
    </div>
</td></tr><tr>
<td valign="top">
    <div id='navtable' height='100%'>
    <div style='margin: 5px'>
        <h4>Documentation</h4>

        <a href="group__asl__overview.html">Overview</a><br/>
        <a href="asl_readme.html">Building ASL</a><br/>
        <a href="asl_toc.html">Documentation</a><br/>
        <a href="http://stlab.adobe.com/wiki/index.php/Supplementary_ASL_Documentation">Library Wiki Docs</a><br/>
        <a href="asl_indices.html">Indices</a><br/>
        <a href="http://stlab.adobe.com/perforce/">Browse Perforce</a><br/>

        <h4>More Info</h4>

        <a href="asl_release_notes.html">Release Notes</a><br/>
        <a href="http://stlab.adobe.com/wiki/">Wiki</a><br/>
        <a href="asl_search.html">Site Search</a><br/>
        <a href="licenses.html">License</a><br/>
        <a href="success_stories.html">Success Stories</a><br/>
        <a href="asl_contributors.html">Contributors</a><br/>

        <h4>Media</h4>

        <a href="http://sourceforge.net/project/showfiles.php?group_id=132417&amp;package_id=145420">Download</a><br/>
        <a href="asl_download_perforce.html">Perforce Depots</a><br/>

        <h4>Support</h4>

        <a href="http://sourceforge.net/projects/adobe-source/">ASL SourceForge Home</a><br/>
        <a href="http://sourceforge.net/mail/?group_id=132417">Mailing Lists</a><br/>
        <a href="http://sourceforge.net/forum/?group_id=132417">Discussion Forums</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724218&amp;group_id=132417&amp;func=browse">Report Bugs</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724221&amp;group_id=132417&amp;func=browse">Suggest Features</a><br/>
        <a href="asl_contributing.html">Contribute to ASL</a><br/>

        <h4>RSS</h4>

        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417">Short-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1">Full-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projfiles.php?group_id=132417">File releases</a><br/>

        <h4>Other Adobe Projects</h4>

        <a href="adobe_apollo.html">Adobe Air</a><br/>
        <a href="http://stlab.adobe.com/gil/">Adobe GIL</a><br/>
        <a href="http://stlab.adobe.com/performance/">C++ Benchmarks</a><br/>
        <a href="http://labs.adobe.com">Adobe Labs</a><br/>
        <a href="http://stlab.adobe.com/amg/">Adobe Media Gallery</a><br/>
        <a href="http://www.adobe.com/products/xmp/">Adobe XMP</a><br/>
        <a href="http://www.mozilla.org/projects/tamarin">Tamarin project<br/>(Mozilla Foundation)</a><br/>

        <h4>Other Resources</h4>

        <a href="http://boost.org">Boost</a><br/>
        <a href="http://www.riaforge.com/">RIAForge</a><br/>
        <a href="http://www.sgi.com/tech/stl">SGI STL</a><br/>
    </div>
    </div>
</td>
<td id='maintable' width="100%" valign="top">

<!-- End Header -->
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1>Move Library<br>
<small>
[<a class="el" href="group__utility.html">Utility</a>]</small>
</h1>The move library is a collection of utilities for creating and using types that leverage return value optimization (RVO) to avoid unnecessary copies.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classadobe_1_1back__move__iterator.html">back_move_iterator&lt; C &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Similar to std::back_insert_iterator but with move semantics, for movable types, otherwise with copy semantics.  <a href="classadobe_1_1back__move__iterator.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1copy__sink.html">copy_sink&lt; T, U, R &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structadobe_1_1copy__sink.html" title="copy_sink and move_sink are used to select between overloaded operations according...">copy_sink</a> and <a class="el" href="structadobe_1_1move__sink.html" title="move_sink and copy_sink are used to select between overloaded operations according...">move_sink</a> are used to <a class="el" href="structadobe_1_1select.html">select</a> between overloaded operations according to whether type T is movable and convertible to type U.  <a href="structadobe_1_1copy__sink.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1is__movable.html">is_movable&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="structadobe_1_1is__movable.html" title="The is_movable trait can be used to identify movable types.">is_movable</a> trait can be used to identify movable types.  <a href="structadobe_1_1is__movable.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1move__from.html">move_from&lt; T &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structadobe_1_1move__from.html" title="move_from is used for move_ctors.">move_from</a> is used for move_ctors.  <a href="structadobe_1_1move__from.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1move__sink.html">move_sink&lt; T, U, R &gt;</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structadobe_1_1move__sink.html" title="move_sink and copy_sink are used to select between overloaded operations according...">move_sink</a> and <a class="el" href="structadobe_1_1copy__sink.html" title="copy_sink and move_sink are used to select between overloaded operations according...">copy_sink</a> are used to <a class="el" href="structadobe_1_1select.html">select</a> between overloaded operations according to whether type T is movable and convertible to type U.  <a href="structadobe_1_1move__sink.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename C &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">back_move_iterator&lt; C &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__move__related.html#g2bce3bf213a2762f43d4d5ecdf86e990">back_mover</a> (C &amp;x)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename I , typename O &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">O&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__move__related.html#g861b306d997a7c9750d75385f6b9fd4b">move</a> (I &amp;in, O out)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename I , typename O &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">O&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__move__related.html#g772e7d266930a324c8d53ceaf6814db3">move</a> (I f, I l, O result)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__move__related.html#gb618fdd195c9dee5111ca0b926aa1f2c">move</a> (T &amp;x, typename copy_sink&lt; T &gt;::type=0)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f">move</a> (T &amp;x, typename move_sink&lt; T &gt;::type=0)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename I , typename O &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">O&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__move__related.html#g9f89399cacd95d825ff569aa3ce94e1c">move_backward</a> (I &amp;in, O out)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename I , typename O &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">O&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__move__related.html#g5447683d5fde8fba2362a1ab114eda89">move_backward</a> (I f, I l, O result)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__move__related.html#gba0d88eb4e6a90cc300de32d97bcf729">move_construct</a> (T *p, const U &amp;x, typename copy_sink&lt; U, T &gt;::type=0)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__move__related.html#g526400c08893d7d421ef40dff01dfa7c">move_construct</a> (T *p, U &amp;x, typename move_sink&lt; U, T &gt;::type=0)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename I , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">F&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__move__related.html#gd89b3999fc477d980388f0c572673d44">uninitialized_move</a> (I f, I l, F r, typename copy_sink&lt; typename std::iterator_traits&lt; I &gt;::value_type &gt;::type=0)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename I , typename F &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">F&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__move__related.html#ge8d7bf1a2a8a34622181803f3cb77f7e">uninitialized_move</a> (I f, I l, F r, typename move_sink&lt; typename std::iterator_traits&lt; I &gt;::value_type &gt;::type=0)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h2><a class="anchor" name="move_tutorial">
Tutorial</a></h2>
User defined types often have remote parts either because they are implemented using a pointer-to-implementation or are variable sized. Such objects can be expensive to copy and are often copied unnecessarily when they are returned from functions or stored in other objects or containers. The <a class="el" href="group__move__related.html">Move Library</a> is a collection of utilities to implement types which can be moved to elide copying in such situations as well as utilities to assist in moving value.<p>
<dl class="user" compact><dt><b>Implementing a Movable Type</b></dt><dd></dd></dl>
A movable type models <a class="el" href="group__concept__movable.html">Movable</a>. There are three components of a movable type:<ul>
<li>Satisfy the requirements of concept <a class="el" href="group__concept__regular__type.html">Regular</a>.</li><li>Implement a move-ctor using move_from&lt;&gt;.</li><li>Modify the assignment operator to take the operand by value and consume it.</li></ul>
<p>
A typical implementation of the move-ctor will simply extract the remote part, leaving the source in a destructible state.<p>
The assignment operator takes the operand parameter by value. Typically the simplest way to destory the local remote part and consume the remote part of the operand is to swap contents with the operand. This is similar to the copy-ctor and swap idiom for implementing assignment.<p>
Listing 1 shows an example movable class that implements a typical pointer-to-implementation (PiPl) idiom and shows that it can be used as any regular type.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;algorithm&gt;</span>

<span class="preprocessor">#include &lt;boost/operators.hpp&gt;</span>

<span class="preprocessor">#include &lt;<a class="code" href="move_8hpp.html">adobe/move.hpp</a>&gt;</span>

<span class="keyword">using</span> <a class="code" href="namespacestd.html#d53fe96196520ac16ec886c7ea05149b">std::swap</a>;

<span class="keyword">struct </span>implementation : boost::<a class="code" href="classboost_1_1equality__comparable.html">equality_comparable</a>&lt;implementation&gt;
{
    <span class="keyword">explicit</span> implementation(<span class="keywordtype">int</span> x = 0) : member(x) { }
    
    implementation(<span class="keyword">const</span> implementation&amp; x) : member(x.member)
    { std::cout &lt;&lt; <span class="stringliteral">"copy remote part: "</span> &lt;&lt; member &lt;&lt; std::endl; }
    
    implementation&amp; operator=(<span class="keyword">const</span> implementation&amp; x)
    {
        member = x.member;
        std::cout &lt;&lt; <span class="stringliteral">"assign remote part: "</span> &lt;&lt; member &lt;&lt; std::endl;
        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }
    
    <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="macintosh__events_8hpp.html#461d48b26b40a79b0407ca492a093ecc">operator==</a>(<span class="keyword">const</span> implementation&amp; x, <span class="keyword">const</span> implementation&amp; y)
    { <span class="keywordflow">return</span> x.member == y.member; }
    
    <span class="keywordtype">int</span> member;
};

<span class="keyword">class </span>movable : <span class="keyword">public</span> boost::<a class="code" href="classboost_1_1equality__comparable.html">equality_comparable</a>&lt;movable&gt;
{
 <span class="keyword">public</span>:
<span class="comment">// model concept Regular</span>

    <span class="keyword">explicit</span> movable(<span class="keywordtype">int</span> x = 0) : member(new implementation(x)) { }
    ~movable() { <span class="keyword">delete</span> member; }
    movable(<span class="keyword">const</span> movable&amp; x) : member(new implementation(*x.member)) { }
    <span class="comment">// operator=() implemented below</span>
    
    <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="macintosh__events_8hpp.html#461d48b26b40a79b0407ca492a093ecc">operator==</a>(<span class="keyword">const</span> movable&amp; x, <span class="keyword">const</span> movable &amp;y)
    { <span class="keywordflow">return</span> *x.member == *y.member; }
    
    <span class="keyword">friend</span> <span class="keywordtype">void</span> <a class="code" href="lex__stream_8hpp.html#af5a67e506e280f605a4dcdf9c35b00c">swap</a>(movable&amp; x, movable&amp; y)
    { <a class="code" href="lex__stream_8hpp.html#af5a67e506e280f605a4dcdf9c35b00c">swap</a>(x.member, y.member); }
    
<span class="comment">// model concept Movable</span>
    
    <span class="comment">// move-ctor assumes ownership of remote part</span>
    movable(<a class="code" href="structadobe_1_1move__from.html" title="move_from is used for move_ctors.">adobe::move_from&lt;movable&gt;</a> x) : member(x.source.member)
    { x.<a class="code" href="structadobe_1_1move__from.html#3fc86dd652c668de2fecaa29375d0d2b">source</a>.member = 0; }
    
    <span class="comment">// operator=() on a movable type takes parameter by value and consumes it</span>
    movable&amp; operator=(movable x)
    { <a class="code" href="lex__stream_8hpp.html#af5a67e506e280f605a4dcdf9c35b00c">swap</a>(*<span class="keyword">this</span>, x); <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
    
 <span class="keyword">private</span>:
    implementation* member;
};

<span class="keywordtype">int</span> main()
{
    movable x(10);
    movable y = x;

    <span class="keywordflow">return</span> 0;
}
</pre></div> <center>Listing 1</center><p>
<div class="fragment"><pre class="fragment">
copy remote part: 10
</pre></div> <center>Output of Listing 1</center><p>
<dl class="user" compact><dt><b>Returning a Movable Type</b></dt><dd></dd></dl>
We can return a movable type from a function by value and unnessary copies will be avoided as Listing 2 illustrates:<p>
<div class="fragment"><pre class="fragment"><span class="comment">//...</span>
movable f(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
{ <span class="keywordflow">return</span> movable(x * y); }

<span class="keywordtype">int</span> main()
{
    movable x = f(10, 5);
    movable y;
    y = f(4, 3);

    <span class="keywordflow">return</span> 0;
}
</pre></div> <center>Listing 2</center><p>
<div class="fragment"><pre class="fragment">

</pre></div> <center>Ouput of Listing 2</center><p>
In this example it is not necessary to make any copies. The result of f() is constructed directly in place for x through a compiler optimization known as return value optimization or RVO. In the case of assigning to y, the same optimization allows the compiler to construct the operand for assignment as the result of f() which is them moved into y.<p>
<dl class="user" compact><dt><b>Implementing a Sink Function</b></dt><dd></dd></dl>
A <em>sink</em> is any function that copies it's argument, usually for the purpose of storing it. A sink is often a constructor or an insert function on a container. The <code>operator=()</code> on a movable type is a form of a sink function. To implement a sink function pass the argument by value and then use <code><a class="el" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">adobe::move()</a></code> to move the argument into place. Note that this technique cannot be used to implement <code>operator=()</code> on because it relies on assignment. Listing 3 implements an example sink function.<p>
<div class="fragment"><pre class="fragment"><span class="comment">//...</span>

<span class="keyword">struct </span>sink
{
    <span class="keyword">explicit</span> sink(movable x) : member(adobe::<a class="code" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">move</a>(x)) { }
    
    movable member;
};

<span class="keywordtype">int</span> main()
{
    movable x = f(10, 5);
    sink y(x);          <span class="comment">// must copy.</span>
    sink z(f(20, 2));   <span class="comment">// no copy.</span>

    <span class="keywordflow">return</span> 0;
}
</pre></div> <center>Listing 3</center><p>
<div class="fragment"><pre class="fragment">
copy remote part: 50
</pre></div> <center>Output of Listing 3</center><p>
Here again unnessary copies are eliminated. Although <a class="el" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">adobe::move()</a> can be used anytime to force the move of an object, it should only be used as part of an explicit sink function otherwise it hinders the understanding of code.<p>
<dl class="user" compact><dt><b>Utilities</b></dt><dd></dd></dl>
There are many utilities as part of the move library which can be used to move elements instead of copying them. These are useful when building containers or dealing with sink operations which must manage a collection of movable objects. Generally these operations parallel the associated copying algorithms from STL. Examples:<p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<td><b>Move</b></td><td><b>Copy</b></td><td><b>Comment</b> </td></tr>
<tr>
<td><a class="el" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">adobe::move()</a></td><td>std::copy</td><td>Not to be confused with the single argument <a class="el" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">adobe::move()</a> </td></tr>
<tr>
<td><a class="el" href="group__move__related.html#g5447683d5fde8fba2362a1ab114eda89" title="Iterator pair version of move_backwards. Similar to std::copy_backwards but with...">adobe::move_backward()</a></td><td>std::copy_backward </td></tr>
<tr>
<td>adobe::back_move_iterator()</td><td>std::back_insert_iterator </td></tr>
<tr>
<td><a class="el" href="group__move__related.html#g2bce3bf213a2762f43d4d5ecdf86e990" title="Similar to std::back_inserter but with move semantics, for movable types, otherwise...">adobe::back_mover()</a></td><td>std::back_inserter </td></tr>
<tr>
<td><a class="el" href="group__move__related.html#g526400c08893d7d421ef40dff01dfa7c" title="Placement move construction, selected when T is_movable is true.">adobe::move_construct()</a></td><td>std::construct </td></tr>
<tr>
<td><a class="el" href="group__move__related.html#ge8d7bf1a2a8a34622181803f3cb77f7e" title="Similar to std::uninitialized_copy but with move semantics, for movable types.">adobe::uninitialized_move()</a></td><td>std::uninitialized_copy </td></tr>
</table>
<p>
<dl class="user" compact><dt><b>Advanced Topics</b></dt><dd></dd></dl>
The <code><a class="el" href="group__move__related.html#g19621039777830b4c316f8956bc5d42f" title="This version of move is selected when T is_movable . It in turn calls the move constructor...">adobe::move()</a></code> function is a NOP if the argument is not movable, however, when a non-movable item is passed to a sink this may still result in an unnecessary copy - one to the sink and one to copy the argument of the sink into place. To avoid the additional copy, two forms of a sink function can be provided, one for movable types and one for copyable types. The <code>adobe::move_sink&lt;&gt;</code> and <code>adobe::copy_sink&lt;&gt;</code> tags can be used to select between the two functions. See the implementation of <code><a class="el" href="group__move__related.html#g526400c08893d7d421ef40dff01dfa7c" title="Placement move construction, selected when T is_movable is true.">adobe::move_construct()</a></code> as an example.<p>
If a sink function is a member of a template class, the same issue with regard to unnecessary copies can occur. In this case, it is desirable to distinguish between the a copy and move sink as above but also to allow implicit conversions to the type stored in the container. To allow this use the two argument form of <code>adobe::move_sink&lt;&gt;</code> and <code>adobe::copy_sink&lt;&gt;</code>. See the implementation of <code><a class="el" href="namespaceadobe_1_1version__1.html#1e0d6f8f7db07684fc6a35e93978db9f">adobe::vector::push_back()</a></code> as an example.<p>
<dl class="user" compact><dt><b>Theory of Operation</b></dt><dd></dd></dl>
<em>to be written</em><p>
<dl class="user" compact><dt><b>Acknowledgments:</b></dt><dd>The move library was inspired by the move library written by Dave Abrahams and the work on move done by Dave Abrahams and Howard Hinnant. </dd></dl>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g2bce3bf213a2762f43d4d5ecdf86e990"></a><!-- doxytag: member="adobe::back_mover" ref="g2bce3bf213a2762f43d4d5ecdf86e990" args="(C &amp;x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">back_move_iterator&lt;C&gt; adobe::back_mover           </td>
          <td>(</td>
          <td class="paramtype">C &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to std::back_inserter but with move semantics, for movable types, otherwise with copy semantics. 
<p>

<p>Definition at line <a class="el" href="move_8hpp_source.html#l00481">481</a> of file <a class="el" href="move_8hpp_source.html">move.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g861b306d997a7c9750d75385f6b9fd4b"></a><!-- doxytag: member="adobe::move" ref="g861b306d997a7c9750d75385f6b9fd4b" args="(I &amp;in, O out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">O adobe::move           </td>
          <td>(</td>
          <td class="paramtype">I &amp;&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&nbsp;</td>
          <td class="paramname"> <em>out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="group__concept__convertible__to__range.html">ConvertibleToRange</a> version of move. Similar to copy but with move semantics, for movable types, otherwise with copy semantics. 
<p>

<p>Definition at line <a class="el" href="move_8hpp_source.html#l00414">414</a> of file <a class="el" href="move_8hpp_source.html">move.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g772e7d266930a324c8d53ceaf6814db3"></a><!-- doxytag: member="adobe::move" ref="g772e7d266930a324c8d53ceaf6814db3" args="(I f, I l, O result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">O adobe::move           </td>
          <td>(</td>
          <td class="paramtype">I&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterator <a class="el" href="structadobe_1_1pair.html">pair</a> version of move. Similar to std::copy but with move semantics, for movable types, otherwise with copy semantics. 
<p>

<p>Definition at line <a class="el" href="move_8hpp_source.html#l00396">396</a> of file <a class="el" href="move_8hpp_source.html">move.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="gb618fdd195c9dee5111ca0b926aa1f2c"></a><!-- doxytag: member="adobe::move" ref="gb618fdd195c9dee5111ca0b926aa1f2c" args="(T &amp;x, typename copy_sink&lt; T &gt;::type=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; adobe::move           </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename copy_sink&lt; T &gt;::type&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This version of move is selected when T is not movable . The net result will be that x gets copied. 
<p>

<p>Definition at line <a class="el" href="move_8hpp_source.html#l00385">385</a> of file <a class="el" href="move_8hpp_source.html">move.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g19621039777830b4c316f8956bc5d42f"></a><!-- doxytag: member="adobe::move" ref="g19621039777830b4c316f8956bc5d42f" args="(T &amp;x, typename move_sink&lt; T &gt;::type=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">T adobe::move           </td>
          <td>(</td>
          <td class="paramtype">T &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename move_sink&lt; T &gt;::type&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This version of move is selected when T <a class="el" href="structadobe_1_1is__movable.html" title="The is_movable trait can be used to identify movable types.">is_movable</a> . It in turn calls the move <a class="el" href="structadobe_1_1constructor.html">constructor</a>. This call, with the help of the return value optimization, will cause x to be moved instead of copied to its destination. See adobe/test/move/main.cpp for examples. 
<p>

<p>Definition at line <a class="el" href="move_8hpp_source.html#l00375">375</a> of file <a class="el" href="move_8hpp_source.html">move.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g9f89399cacd95d825ff569aa3ce94e1c"></a><!-- doxytag: member="adobe::move_backward" ref="g9f89399cacd95d825ff569aa3ce94e1c" args="(I &amp;in, O out)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">O adobe::move_backward           </td>
          <td>(</td>
          <td class="paramtype">I &amp;&nbsp;</td>
          <td class="paramname"> <em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&nbsp;</td>
          <td class="paramname"> <em>out</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="group__concept__convertible__to__range.html">ConvertibleToRange</a> version of move_backwards. Similar to std::copy_backwards but with move semantics, for movable types, otherwise with copy semantics. 
<p>

<p>Definition at line <a class="el" href="move_8hpp_source.html#l00443">443</a> of file <a class="el" href="move_8hpp_source.html">move.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g5447683d5fde8fba2362a1ab114eda89"></a><!-- doxytag: member="adobe::move_backward" ref="g5447683d5fde8fba2362a1ab114eda89" args="(I f, I l, O result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">O adobe::move_backward           </td>
          <td>(</td>
          <td class="paramtype">I&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&nbsp;</td>
          <td class="paramname"> <em>result</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Iterator <a class="el" href="structadobe_1_1pair.html">pair</a> version of move_backwards. Similar to std::copy_backwards but with move semantics, for movable types, otherwise with copy semantics. 
<p>

<p>Definition at line <a class="el" href="move_8hpp_source.html#l00425">425</a> of file <a class="el" href="move_8hpp_source.html">move.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="gba0d88eb4e6a90cc300de32d97bcf729"></a><!-- doxytag: member="adobe::move_construct" ref="gba0d88eb4e6a90cc300de32d97bcf729" args="(T *p, const U &amp;x, typename copy_sink&lt; U, T &gt;::type=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void adobe::move_construct           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename copy_sink&lt; U, T &gt;::type&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Placement copy construction, selected when T <a class="el" href="structadobe_1_1is__movable.html" title="The is_movable trait can be used to identify movable types.">is_movable</a> is false. 
<p>

<p>Definition at line <a class="el" href="move_8hpp_source.html#l00504">504</a> of file <a class="el" href="move_8hpp_source.html">move.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g526400c08893d7d421ef40dff01dfa7c"></a><!-- doxytag: member="adobe::move_construct" ref="g526400c08893d7d421ef40dff01dfa7c" args="(T *p, U &amp;x, typename move_sink&lt; U, T &gt;::type=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void adobe::move_construct           </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename move_sink&lt; U, T &gt;::type&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Placement move construction, selected when T <a class="el" href="structadobe_1_1is__movable.html" title="The is_movable trait can be used to identify movable types.">is_movable</a> is true. 
<p>

<p>Definition at line <a class="el" href="move_8hpp_source.html#l00491">491</a> of file <a class="el" href="move_8hpp_source.html">move.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="gd89b3999fc477d980388f0c572673d44"></a><!-- doxytag: member="adobe::uninitialized_move" ref="gd89b3999fc477d980388f0c572673d44" args="(I f, I l, F r, typename copy_sink&lt; typename std::iterator_traits&lt; I &gt;::value_type &gt;::type=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F adobe::uninitialized_move           </td>
          <td>(</td>
          <td class="paramtype">I&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename copy_sink&lt; typename std::iterator_traits&lt; I &gt;::value_type &gt;::type&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Behaves as to std::uninitialized_copy , invoked when I's value_type is not movable. 
<p>

<p>Definition at line <a class="el" href="move_8hpp_source.html#l00536">536</a> of file <a class="el" href="move_8hpp_source.html">move.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="ge8d7bf1a2a8a34622181803f3cb77f7e"></a><!-- doxytag: member="adobe::uninitialized_move" ref="ge8d7bf1a2a8a34622181803f3cb77f7e" args="(I f, I l, F r, typename move_sink&lt; typename std::iterator_traits&lt; I &gt;::value_type &gt;::type=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">F adobe::uninitialized_move           </td>
          <td>(</td>
          <td class="paramtype">I&nbsp;</td>
          <td class="paramname"> <em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&nbsp;</td>
          <td class="paramname"> <em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename move_sink&lt; typename std::iterator_traits&lt; I &gt;::value_type &gt;::type&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Similar to std::uninitialized_copy but with move semantics, for movable types. 
<p>

<p>Definition at line <a class="el" href="move_8hpp_source.html#l00518">518</a> of file <a class="el" href="move_8hpp_source.html">move.hpp</a>.</p>

</div>
</div><p>
</div>

<!-- Begin Footer -->
</td></tr>
</table>
</div> <!-- content -->
<div class='footerdiv'>
    <div id='footersub'>
        <ul>
            <li><a href="http://www.adobe.com/go/gftray_foot_aboutadobe">Company</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_contact_adobe">Contact Us</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_accessibility">Accessibility</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_report_piracy">Report Piracy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_permissions_trademarks">Permissions &amp; Trademarks</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_product_license_agreements">Product License Agreements</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_feedback">Send Feedback</a></li>
        </ul>
        <div>
            <p>Copyright &#169; 2006-2007 Adobe Systems Incorporated.</p>
            <p>Use of this website signifies your agreement to the <a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a> and <a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>.</p>
            <p>Search powered by <a href="http://www.google.com/" target="new">Google</a></p>
        </div>
	</div>
</div>
<script type="text/javascript">
_uacct = "UA-396569-1";
urchinTracker();
</script>
</body>
</html>
