<!--
    Copyright 2005-2008 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://stlab.adobe.com/licenses.html)

    Some files are held under additional license.
    Please see "http://stlab.adobe.com/licenses.html" for more information.
-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <TITLE>Adobe Software Technology Lab: xstring Glossary System</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="adobe_source.css"/>
    <LINK REL="alternate" TITLE="stlab.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
</head>
<body>
<div id='content'>
<table><tr>
<td colspan='5'>
    <div id='opensource_banner'>
    <table style='width: 100%; padding: 5px;'><tr>
    <td align='left'>
        <a href='index.html' style='border: none'><img src='stlab2007.jpg' alt="stlab.adobe.com"/></a>
    </td>
    <td align='right'>
        <a href='http://www.adobe.com' style='border: none'><img src='adobe_hlogo.gif' alt="Adobe Systems Incorporated"/></a>
    </td>
    </tr></table>
    </div>
</td></tr><tr>
<td valign="top">
    <div id='navtable' height='100%'>
    <div style='margin: 5px'>
        <h4>Documentation</h4>

        <a href="group__asl__overview.html">Overview</a><br/>
        <a href="asl_readme.html">Building ASL</a><br/>
        <a href="asl_toc.html">Documentation</a><br/>
        <a href="http://stlab.adobe.com/wiki/index.php/Supplementary_ASL_Documentation">Library Wiki Docs</a><br/>
        <a href="asl_indices.html">Indices</a><br/>
        <a href="http://stlab.adobe.com/perforce/">Browse Perforce</a><br/>

        <h4>More Info</h4>

        <a href="asl_release_notes.html">Release Notes</a><br/>
        <a href="http://stlab.adobe.com/wiki/">Wiki</a><br/>
        <a href="asl_search.html">Site Search</a><br/>
        <a href="licenses.html">License</a><br/>
        <a href="success_stories.html">Success Stories</a><br/>
        <a href="asl_contributors.html">Contributors</a><br/>

        <h4>Media</h4>

        <a href="http://sourceforge.net/project/showfiles.php?group_id=132417&amp;package_id=145420">Download</a><br/>
        <a href="asl_download_perforce.html">Perforce Depots</a><br/>

        <h4>Support</h4>

        <a href="http://sourceforge.net/projects/adobe-source/">ASL SourceForge Home</a><br/>
        <a href="http://sourceforge.net/mail/?group_id=132417">Mailing Lists</a><br/>
        <a href="http://sourceforge.net/forum/?group_id=132417">Discussion Forums</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724218&amp;group_id=132417&amp;func=browse">Report Bugs</a><br/>
        <a href="http://sourceforge.net/tracker/?atid=724221&amp;group_id=132417&amp;func=browse">Suggest Features</a><br/>
        <a href="asl_contributing.html">Contribute to ASL</a><br/>

        <h4>RSS</h4>

        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417">Short-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1">Full-text news</a><br/>
        <a href="http://sourceforge.net/export/rss2_projfiles.php?group_id=132417">File releases</a><br/>

        <h4>Other Adobe Projects</h4>

        <a href="adobe_apollo.html">Adobe Air</a><br/>
        <a href="http://stlab.adobe.com/gil/">Adobe GIL</a><br/>
        <a href="http://stlab.adobe.com/performance/">C++ Benchmarks</a><br/>
        <a href="http://labs.adobe.com">Adobe Labs</a><br/>
        <a href="http://stlab.adobe.com/amg/">Adobe Media Gallery</a><br/>
        <a href="http://www.adobe.com/products/xmp/">Adobe XMP</a><br/>
        <a href="http://www.mozilla.org/projects/tamarin">Tamarin project<br/>(Mozilla Foundation)</a><br/>

        <h4>Other Resources</h4>

        <a href="http://boost.org">Boost</a><br/>
        <a href="http://www.riaforge.com/">RIAForge</a><br/>
        <a href="http://www.sgi.com/tech/stl">SGI STL</a><br/>
    </div>
    </div>
</td>
<td id='maintable' width="100%" valign="top">

<!-- End Header -->
<!-- Generated by Doxygen 1.5.9 -->
<div class="contents">
<h1>xstring Glossary System<br>
<small>
[<a class="el" href="group__parsing.html">Parsing, Serialization, and Strings</a>]</small>
</h1>A context-sensitive string lookup system.  
<a href="#_details">More...</a>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structadobe_1_1xstring__context__t.html">xstring_context_t</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scope-based runtime context stack for glossary lookups.  <a href="structadobe_1_1xstring__context__t.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef boost::function<br class="typebreak">
&lt; implementation_xml_element_proc_t &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asl__xstring.html#g3cba22a3d7415214dfdfee7b2d3d5f2f">xml_element_proc_t</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename O &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__asl__xstring.html#g06468e312965ce2bc8c9c0b11b3ee226">parse_xml_fragment</a> (const char *fragment, O output)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename O &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__asl__xstring.html#g7c5e15472e44aeb29700aa7a118b00d1">parse_xml_fragment</a> (const std::string &amp;fragment, O output)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename O &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__asl__xstring.html#g2305f437e04f874d3274f835969449f0">parse_xml_fragment</a> (uchar_ptr_t fragment, std::size_t n, O output)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename O &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__asl__xstring.html#g4a6c9bc5c8173bdfa8e1133013995de4">xstring</a> (const char *xstr, O output)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename O &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__asl__xstring.html#gb3fc1d5d2bb1f0e27bd3cee45f2ef6cf">xstring</a> (const char *xstr, std::size_t n, O output)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asl__xstring.html#g52cbc5ffb837f882d7c4a37464ae515d">xstring</a> (const std::string &amp;xstr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asl__xstring.html#g9308cb9f1187c3d4ee231a3523fad022">xstring</a> (const char *xstr, std::size_t n)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asl__xstring.html#g9d76927262d5c8b0cedd65214b210f30">xstring_clear_glossary</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asl__xstring.html#ge3686ba33fdd78acfafd466cc0cd515d">xstring_replace</a> (const name_t &amp;xstr_id, const std::string *first, const std::string *last)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asl__xstring.html#g560e820b5a3125465d252fd9829db743">xstring_replace</a> (const name_t &amp;xstr_id, const std::string &amp;marker)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asl__xstring.html#gd22df7044bf6bed4b5f82132c6d7bd4f">xstring_replace</a> (const std::string &amp;xstr, const std::string *first, const std::string *last)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">std::string&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asl__xstring.html#g8a6d63638d971bdb901a955ee12b7c76">xstring_replace</a> (const std::string &amp;xstr, const std::string &amp;marker)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The xstring implementation is thread safe when compiled with BOOST_HAS_THREADS defined.</dd></dl>
<dl class="todo" compact><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>(fbrereto) The language code should be obtained at runtime instead of hard-coded to 'en-us'</dd></dl>
<h2><a class="anchor" name="xstring_grammar">
xstring Grammar</a></h2>
The xstring grammar is based on the XML 1.1 grammar specification (<a href="http://www.w3.org/TR/2004/REC-xml11-20040204/">http://www.w3.org/TR/2004/REC-xml11-20040204/</a>) <div class="fragment"><pre class="fragment">
S                   =   (#x20 | #x09 | #x0D | #x0A)+

Char                =   [#x1-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]

CharData            =   [^&lt;&amp;]*

CharRef             =   '&amp;#' [0-9]+ ';' | '&amp;#x' [0-9a-fA-F]+ ';'

NameStartChar       =   ":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] |
                        [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] |
                        [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] |
                        [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] |
                        [#x10000-#xEFFFF]

NameChar            =   NameStartChar | "-" | "." | [0-9] | #xB7 |
                        [#x0300-#x036F] | [#x203F-#x2040]

Name                =   NameStartChar (NameChar)*

EntityRef           =   '&amp;' Name ';'

Reference           =   EntityRef | CharRef

AttValue            =   '"' ([^&lt;&amp;"] | Reference)* '"' |
                        "'" ([^&lt;&amp;'] | Reference)* "'"

Eq                  =   S? '=' S?

Attribute           =   Name Eq AttValue

EmptyElemTag        =   '&lt;' Name (S Attribute)* S? '/&gt;'

STag                =   '&lt;' Name (S Attribute)* S? '&gt;'

ETag                =   '&lt;/' Name S? '&gt;'

content             =   CharData? ((element | Reference | Comment) CharData?)*

element             =   EmptyElemTag | STag content ETag

translation_unit    =   element*
</pre></div><h2><a class="anchor" name="xstring_context">
Context</a></h2>
<h3><a class="anchor" name="xstring_context_overview">
Overview</a></h3>
The context of a string is a runtime evaluated collection of information about the state of the machine and the xstring that we currently care about. This context is gathered from several locations:<p>
<ol type=1>
<li>the runtime context of the xstring system (which includes some defaults)</li><li>the static attributes of the xstring definition</li></ol>
<p>
The runtime context of the xstring system can be manipulated with the <a class="el" href="structadobe_1_1xstring__context__t.html" title="Scope-based runtime context stack for glossary lookups.">adobe::xstring_context_t</a> class. The runtime context has several pieces of information set by default. These pieces are:<ul>
<li>lang : defaults to 'en-us'</li><li>platform : defaults to one of several target platform tags:<ul>
<li>"linux"</li><li>"bsd"</li><li>"solaris"</li><li>"irix"</li><li>"hpux"</li><li>"cygwin"</li><li>"windows"</li><li>"beos"</li><li>"macintosh"</li><li>"aix"</li><li>"amiga"</li><li>"unix"</li></ul>
</li></ul>
<p>
The static attributes of the xstring definition also provide context. Example: <div class="fragment"><pre class="fragment">
&lt;xstr id='hello_world' lang='es-sp'&gt;Hola, mundo!&lt;/xstr&gt;
</pre></div><p>
In the above example the two bits of context are 'id' and 'lang'. These override specific context information as outlined in the "Context Merging" section.<h3><a class="anchor" name="xstring_context_merging">
Merging</a></h3>
There are several context merges that take place in the use of the xstring system. Context merges are necessary because there are several places from which the context of a string is gathered, and conflicting pieces of context must be resolved before the string can be imported into or looked up in the xstring glossary. This section describes the rules by which parts of one source context overrides another to obtain the final context for an xstring.<h4><a class="anchor" name="xstring_context_merging_import">
Merging During Importing Into the Glossary</a></h4>
When importing into the glossary the only context taken into account is the static context defined in the xstring.<h4><a class="anchor" name="xstring_context_merging_lookup">
Merging During Lookup</a></h4>
When looking up an xstring in the glossary, first the xstring is parsed to obtain its static context. The runtime context defined by <a class="el" href="structadobe_1_1xstring__context__t.html" title="Scope-based runtime context stack for glossary lookups.">adobe::xstring_context_t</a> is then merged with the static context, and the static context value takes precedence in the case of a conflict.<h3><a class="anchor" name="xstring_context_lookup">
Lookup</a></h3>
During lookup, the source xstring context is completely resolved first. Then the source xstring is compared to the xstrings in the glossary that have the same <code>id</code> key value. Of those xstrings with the same <code>id</code> key value, the xstring selected from the glossary is the one whose attribute set is the largest subset of the source xstring.<h2><a class="anchor" name="xstring_marker_replacement">
Marker Replacement</a></h2>
It is possible for the xstring system to handle marker replacement inside xstrings. A marker is simply an xml tag in an xstring to be removed later and replaced with another string (which itself can be the product of a previous xstring lookup). An example might be: <div class="fragment"><pre class="fragment">
&lt;xstr id='greeting'&gt;Hello, &lt;marker id='user_name'/&gt;&lt;/xstr&gt;
</pre></div><p>
During xstring marker replacement the engine will extract all the xstrings in the glossary with the same <code>id</code> key value. Markers are matched based on their attribute sets: in order for a marker to be replaced in an xstring its attribute set must match the source marker's attribute set perfectly. If a marker in the xstring cannot be replaced by one of the supplied markers, it is an error for that xstring, and the engine moves on to the next candidate. Of the set of xstrings in the glossary with the same <code>id</code> key value, the final xstring selected is the one that had the most markers replaced without error. This means, then, that it is possible to have xstrings be selected based on the markers passed in to resolve them.<h3><a class="anchor" name="xstring_marker_replacement_example">
Example</a></h3>
Given the following in the xstring glossary: <div class="fragment"><pre class="fragment">
&lt;xstr id='replacement_test_1'&gt;I think &lt;marker id='good_thing'/&gt; is a Good Thing&lt;/xstr&gt;
&lt;xstr id='replacement_test_1'&gt;I think &lt;marker id='bad_thing'/&gt; is a Bad Thing&lt;/xstr&gt;
&lt;xstr id='replacement_test_1'&gt;I don't think anything about &lt;marker id='whatever'/&gt;&lt;/xstr&gt;

&lt;xstr id="a_good_thing"&gt;&lt;marker id="good_thing"&gt;ice cream&lt;/marker&gt;&lt;/xstr&gt;
&lt;xstr id="a_bad_thing"&gt;&lt;marker id="bad_thing"&gt;the Taliban&lt;/marker&gt;&lt;/xstr&gt;
&lt;xstr id="a_neutral_thing"&gt;&lt;marker id="whatever"&gt;yellow traffic lights&lt;/marker&gt;&lt;/xstr&gt;
</pre></div><p>
And given the following code: <div class="fragment"><pre class="fragment">std::string good_thing(<a class="code" href="group__asl__xstring.html#gb3fc1d5d2bb1f0e27bd3cee45f2ef6cf">adobe::xstring</a>(<span class="stringliteral">"&lt;xstr id='a_good_thing'/&gt;"</span>));
std::string bad_thing(<a class="code" href="group__asl__xstring.html#gb3fc1d5d2bb1f0e27bd3cee45f2ef6cf">adobe::xstring</a>(<span class="stringliteral">"&lt;xstr id='a_bad_thing'/&gt;"</span>));
std::string neutral_thing(<a class="code" href="group__asl__xstring.html#gb3fc1d5d2bb1f0e27bd3cee45f2ef6cf">adobe::xstring</a>(<span class="stringliteral">"&lt;xstr id='a_neutral_thing'/&gt;"</span>));

std::cout &lt;&lt; <span class="stringliteral">"good marker: "</span> &lt;&lt; good_thing &lt;&lt; std::endl;
std::cout &lt;&lt; <span class="stringliteral">"bad marker: "</span> &lt;&lt; bad_thing &lt;&lt; std::endl;
std::cout &lt;&lt; <span class="stringliteral">"neutral marker: "</span> &lt;&lt; neutral_thing &lt;&lt; std::endl;

std::cout &lt;&lt; <span class="stringliteral">"Good: "</span> &lt;&lt; <a class="code" href="group__asl__xstring.html#g8a6d63638d971bdb901a955ee12b7c76">adobe::xstring_replace</a>(<a class="code" href="classadobe_1_1static__name__t.html" title="Utility wrapper to construct name_t with strings of static storage duration.">adobe::static_name_t</a>(<span class="stringliteral">"replacement_test_1"</span>), good_thing) &lt;&lt; std::endl;
std::cout &lt;&lt; <span class="stringliteral">"Bad: "</span> &lt;&lt; <a class="code" href="group__asl__xstring.html#g8a6d63638d971bdb901a955ee12b7c76">adobe::xstring_replace</a>(<a class="code" href="classadobe_1_1static__name__t.html" title="Utility wrapper to construct name_t with strings of static storage duration.">adobe::static_name_t</a>(<span class="stringliteral">"replacement_test_1"</span>), bad_thing) &lt;&lt; std::endl;
std::cout &lt;&lt; <span class="stringliteral">"Neutral: "</span> &lt;&lt; <a class="code" href="group__asl__xstring.html#g8a6d63638d971bdb901a955ee12b7c76">adobe::xstring_replace</a>(<a class="code" href="classadobe_1_1static__name__t.html" title="Utility wrapper to construct name_t with strings of static storage duration.">adobe::static_name_t</a>(<span class="stringliteral">"replacement_test_1"</span>), neutral_thing) &lt;&lt; std::endl;
</pre></div><p>
We get the following output: <div class="fragment"><pre class="fragment">
good marker: &lt;marker id='good_thing'&gt;ice cream&lt;/marker&gt;
bad marker: &lt;marker id='bad_thing'&gt;the Taliban&lt;/marker&gt;
neutral marker: &lt;marker id='whatever'&gt;yellow traffic lights&lt;/marker&gt;
Good: I think ice cream is a Good Thing
Bad: I think the Taliban is a Bad Thing
Neutral: I don't think anything about yellow traffic lights
</pre></div><p>
Note first of all that we extracted our markers from the xstring glossary itself before we used them for marker replacement. This gives you the ability to localize your markers before you use them in marker replacement.<p>
Note also that there are three xstrings with the <code>id</code> of <code>replacement_test_1</code>. The xstring replacement engine considered all of those xstrings in every iteration of marker replacement, however the results changed because the provided markers had varying attribute sets.<h3><a class="anchor" name="xstring_marker_replacement_notes">
Marker Replacement Notes</a></h3>
Within a single marker replacement pass, it is illegal to have one marker directly nested within another marker, either in the source xstring or as a replacement marker, e.g.:<p>
<div class="fragment"><pre class="fragment">
&lt;marker id="foo"&gt;&lt;marker id="bar"/&gt;&lt;/marker&gt;
</pre></div><p>
Other XML tags, however, are allowed. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g3cba22a3d7415214dfdfee7b2d3d5f2f"></a><!-- doxytag: member="adobe::xml_element_proc_t" ref="g3cba22a3d7415214dfdfee7b2d3d5f2f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">xml_element_proc_t          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Callback for the XML fragment parser. When the fragment parser finds a well formed <a class="el" href="structadobe_1_1element.html">element</a>, it will signal a function with this signature with the following parameters:<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>The name of the <a class="el" href="structadobe_1_1element.html">element</a> </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attribute_set</em>&nbsp;</td><td>A collection of attributes for the found <a class="el" href="structadobe_1_1element.html">element</a> (could be empty) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The character data contained within the <a class="el" href="structadobe_1_1element.html">element</a> (could be empty)</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A UTF8 buffer that is the value of this <a class="el" href="structadobe_1_1element.html">element</a>. The value is dependent on the implementation of the callback (for example, see xml_element_echo). </dd></dl>

<p>Definition at line <a class="el" href="xml__parser_8hpp_source.html#l00436">436</a> of file <a class="el" href="xml__parser_8hpp_source.html">xml_parser.hpp</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g06468e312965ce2bc8c9c0b11b3ee226"></a><!-- doxytag: member="adobe::parse_xml_fragment" ref="g06468e312965ce2bc8c9c0b11b3ee226" args="(const char *fragment, O output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string parse_xml_fragment           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>fragment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&nbsp;</td>
          <td class="paramname"> <em>output</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parses a fragment of XML, outputting the result to an OutputIterator instance.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fragment</em>&nbsp;</td><td>Null-terminated 7-bit ASCII encoded fragment of XML to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>output</em>&nbsp;</td><td>OutputIterator implementation that receives the result of the parse</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the parsed fragment </dd></dl>

<p>Definition at line <a class="el" href="xstring_8hpp_source.html#l00224">224</a> of file <a class="el" href="xstring_8hpp_source.html">xstring.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g7c5e15472e44aeb29700aa7a118b00d1"></a><!-- doxytag: member="adobe::parse_xml_fragment" ref="g7c5e15472e44aeb29700aa7a118b00d1" args="(const std::string &amp;fragment, O output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string parse_xml_fragment           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>fragment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&nbsp;</td>
          <td class="paramname"> <em>output</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parses a fragment of XML, outputting the result to an OutputIterator instance.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fragment</em>&nbsp;</td><td>utf-8 encoded fragment of XML to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>output</em>&nbsp;</td><td>OutputIterator implementation that receives the result of the parse</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the parsed fragment </dd></dl>

<p>Definition at line <a class="el" href="xstring_8hpp_source.html#l00220">220</a> of file <a class="el" href="xstring_8hpp_source.html">xstring.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g2305f437e04f874d3274f835969449f0"></a><!-- doxytag: member="adobe::parse_xml_fragment" ref="g2305f437e04f874d3274f835969449f0" args="(uchar_ptr_t fragment, std::size_t n, O output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string parse_xml_fragment           </td>
          <td>(</td>
          <td class="paramtype">uchar_ptr_t&nbsp;</td>
          <td class="paramname"> <em>fragment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&nbsp;</td>
          <td class="paramname"> <em>output</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parses a fragment of XML, outputting the result to an OutputIterator instance.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fragment</em>&nbsp;</td><td>utf-8 encoded fragment of XML to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>Number of bytes in the fragment </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>output</em>&nbsp;</td><td>OutputIterator implementation that receives the result of the parse</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The value of the parsed fragment </dd></dl>

<p>Definition at line <a class="el" href="xstring_8hpp_source.html#l00205">205</a> of file <a class="el" href="xstring_8hpp_source.html">xstring.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g4a6c9bc5c8173bdfa8e1133013995de4"></a><!-- doxytag: member="adobe::xstring" ref="g4a6c9bc5c8173bdfa8e1133013995de4" args="(const char *xstr, O output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xstring           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>xstring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&nbsp;</td>
          <td class="paramname"> <em>output</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xstring</em>&nbsp;</td><td>Null-terminated 7-bit ASCII encoded xstring definition (an XML <a class="el" href="structadobe_1_1element.html">element</a> fragment) to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>output</em>&nbsp;</td><td>Type that models OutputIterator; recieves the result of the xstring lookup.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The glossary-obtained xstring value, or the default string if none is found in the glossary. This result will be a valid XML fragment</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>When compiled without <code>NDEBUG</code> defined, if the string is not found in the glossary it will be added. This is useful for checking for duplicate entries across your application. </dd></dl>

<p>Definition at line <a class="el" href="xstring_8hpp_source.html#l00236">236</a> of file <a class="el" href="xstring_8hpp_source.html">xstring.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="gb3fc1d5d2bb1f0e27bd3cee45f2ef6cf"></a><!-- doxytag: member="adobe::xstring" ref="gb3fc1d5d2bb1f0e27bd3cee45f2ef6cf" args="(const char *xstr, std::size_t n, O output)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xstring           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>xstring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">O&nbsp;</td>
          <td class="paramname"> <em>output</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xstring</em>&nbsp;</td><td>7-bit ASCII encoded xstring definition (an XML <a class="el" href="structadobe_1_1element.html">element</a> fragment) to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>size of the input buffer </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>output</em>&nbsp;</td><td>Type that models OutputIterator; recieves the result of the xstring lookup.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The glossary-obtained xstring value, or the default string if none is found in the glossary. This result will be a valid XML fragment</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>When compiled without <code>NDEBUG</code> defined, if the string is not found in the glossary it will be added. This is useful for checking for duplicate entries across your application. </dd></dl>

<p>Definition at line <a class="el" href="xstring_8hpp_source.html#l00232">232</a> of file <a class="el" href="xstring_8hpp_source.html">xstring.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g52cbc5ffb837f882d7c4a37464ae515d"></a><!-- doxytag: member="adobe::xstring" ref="g52cbc5ffb837f882d7c4a37464ae515d" args="(const std::string &amp;xstr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string xstring           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>xstr</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xstr</em>&nbsp;</td><td>utf-8 buffer of the xstring defintion to parse and look up</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The glossary-obtained xstring value, or the default string if none is found in the glossary. This result will be a valid XML fragment</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>When compiled without <code>NDEBUG</code> defined, if the string is not found in the glossary it will be added. This is useful for checking for duplicate entries across your application. </dd></dl>

<p>Definition at line <a class="el" href="xstring_8hpp_source.html#l00252">252</a> of file <a class="el" href="xstring_8hpp_source.html">xstring.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g9308cb9f1187c3d4ee231a3523fad022"></a><!-- doxytag: member="adobe::xstring" ref="g9308cb9f1187c3d4ee231a3523fad022" args="(const char *xstr, std::size_t n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string xstring           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>xstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xstr</em>&nbsp;</td><td>7-bit ASCII encoded xstring definition (an XML <a class="el" href="structadobe_1_1element.html">element</a> fragment) to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>size of the input buffer</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The glossary-obtained xstring value, or the default string if none is found in the glossary. This result will be a valid XML fragment</dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>When compiled without <code>NDEBUG</code> defined, if the string is not found in the glossary it will be added. This is useful for checking for duplicate entries across your application. </dd></dl>

<p>Definition at line <a class="el" href="xstring_8hpp_source.html#l00243">243</a> of file <a class="el" href="xstring_8hpp_source.html">xstring.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="g9d76927262d5c8b0cedd65214b210f30"></a><!-- doxytag: member="adobe::xstring_clear_glossary" ref="g9d76927262d5c8b0cedd65214b210f30" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xstring_clear_glossary           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the entire contents of the xstring glossary<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This is available only for builds where <code>NDEBUG</code> is not defined </dd></dl>

</div>
</div><p>
<a class="anchor" name="ge3686ba33fdd78acfafd466cc0cd515d"></a><!-- doxytag: member="adobe::xstring_replace" ref="ge3686ba33fdd78acfafd466cc0cd515d" args="(const name_t &amp;xstr_id, const std::string *first, const std::string *last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string xstring_replace           </td>
          <td>(</td>
          <td class="paramtype">const name_t &amp;&nbsp;</td>
          <td class="paramname"> <em>xstr_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string *&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string *&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xstr_id</em>&nbsp;</td><td>xstring to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>first marker to be used to replace those found in best-fitting xstring </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>one-past the last marker</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The glossary-obtained xstring value with the markers appropriately replaced. This result will be a valid XML fragment</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::runtime_error</em>&nbsp;</td><td>Thrown when marker replacement attempts on all of the candidate xstrings resulted in an error. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g560e820b5a3125465d252fd9829db743"></a><!-- doxytag: member="adobe::xstring_replace" ref="g560e820b5a3125465d252fd9829db743" args="(const name_t &amp;xstr_id, const std::string &amp;marker)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string xstring_replace           </td>
          <td>(</td>
          <td class="paramtype">const name_t &amp;&nbsp;</td>
          <td class="paramname"> <em>xstr_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>marker</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xstr_id</em>&nbsp;</td><td>xstring to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>marker</em>&nbsp;</td><td>marker to be used to replace those found in best-fitting xstring</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The glossary-obtained xstring value with the markers appropriately replaced. This result will be a valid XML fragment</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::runtime_error</em>&nbsp;</td><td>Thrown when marker replacement attempts on all of the candidate xstrings resulted in an error. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="gd22df7044bf6bed4b5f82132c6d7bd4f"></a><!-- doxytag: member="adobe::xstring_replace" ref="gd22df7044bf6bed4b5f82132c6d7bd4f" args="(const std::string &amp;xstr, const std::string *first, const std::string *last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string xstring_replace           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>xstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string *&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string *&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xstr</em>&nbsp;</td><td>xstring to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>first</em>&nbsp;</td><td>first marker to be used to replace those found in best-fitting xstring </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>one-past the last marker</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The only piece of information used from this source xstring is the <code>id</code> attribute value. If you have access to this value without needing to parse the xstring, use the alternate form of xstring_replace that takes just the xstring id.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The glossary-obtained xstring value with the markers appropriately replaced. This result will be a valid XML fragment</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::runtime_error</em>&nbsp;</td><td>Thrown when marker replacement attempts on all of the candidate xstrings resulted in an error. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="g8a6d63638d971bdb901a955ee12b7c76"></a><!-- doxytag: member="adobe::xstring_replace" ref="g8a6d63638d971bdb901a955ee12b7c76" args="(const std::string &amp;xstr, const std::string &amp;marker)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string xstring_replace           </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>xstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&nbsp;</td>
          <td class="paramname"> <em>marker</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xstr</em>&nbsp;</td><td>xstring to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>marker</em>&nbsp;</td><td>marker to be used to replace those found in best-fitting xstring</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>The only piece of information used from this source xstring is the <code>id</code> attribute value. If you have access to this value without needing to parse the xstring, use the alternate form of xstring_replace that takes just the xstring id.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The glossary-obtained xstring value with the markers appropriately replaced. This result will be a valid XML fragment</dd></dl>
<dl compact><dt><b>Exceptions:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>std::runtime_error</em>&nbsp;</td><td>Thrown when marker replacement attempts on all of the candidate xstrings resulted in an error. </td></tr>
  </table>
</dl>

</div>
</div><p>
</div>

<!-- Begin Footer -->
</td></tr>
</table>
</div> <!-- content -->
<div class='footerdiv'>
    <div id='footersub'>
        <ul>
            <li><a href="http://www.adobe.com/go/gftray_foot_aboutadobe">Company</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_contact_adobe">Contact Us</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_accessibility">Accessibility</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_report_piracy">Report Piracy</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_permissions_trademarks">Permissions &amp; Trademarks</a>&nbsp;|&nbsp;</li>
            <li><a href="http://www.adobe.com/go/gftray_foot_product_license_agreements">Product License Agreements</a>&nbsp;|&nbsp;</li>
    
            <li><a href="http://www.adobe.com/go/gftray_foot_feedback">Send Feedback</a></li>
        </ul>
        <div>
            <p>Copyright &#169; 2006-2007 Adobe Systems Incorporated.</p>
            <p>Use of this website signifies your agreement to the <a href="http://www.adobe.com/go/gftray_foot_terms">Terms of Use</a> and <a href="http://www.adobe.com/go/gftray_foot_privacy_security">Online Privacy Policy</a>.</p>
            <p>Search powered by <a href="http://www.google.com/" target="new">Google</a></p>
        </div>
	</div>
</div>
<script type="text/javascript">
_uacct = "UA-396569-1";
urchinTracker();
</script>
</body>
</html>
